SCRIPT  /Users/mochi/.local/share/nvim/plugged/fzf/plugin/fzf.vim
Sourced 1 time
Total time:   0.001542
 Self time:   0.001542

count  total (s)   self (s)
                            " Copyright (c) 2017 Junegunn Choi
                            "
                            " MIT License
                            "
                            " Permission is hereby granted, free of charge, to any person obtaining
                            " a copy of this software and associated documentation files (the
                            " "Software"), to deal in the Software without restriction, including
                            " without limitation the rights to use, copy, modify, merge, publish,
                            " distribute, sublicense, and/or sell copies of the Software, and to
                            " permit persons to whom the Software is furnished to do so, subject to
                            " the following conditions:
                            "
                            " The above copyright notice and this permission notice shall be
                            " included in all copies or substantial portions of the Software.
                            "
                            " THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
                            " EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
                            " MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
                            " NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                            " LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
                            " OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
                            " WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                            
    1              0.000005 if exists('g:loaded_fzf')
                              finish
    1              0.000001 endif
    1              0.000002 let g:loaded_fzf = 1
                            
    1              0.000006 let s:is_win = has('win32') || has('win64')
    1              0.000001 if s:is_win && &shellslash
                              set noshellslash
                              let s:base_dir = expand('<sfile>:h:h')
                              set shellslash
    1              0.000001 else
    1              0.000003   let s:base_dir = expand('<sfile>:h:h')
    1              0.000001 endif
    1              0.000001 if s:is_win
                              let s:term_marker = '&::FZF'
                            
                              function! s:fzf_call(fn, ...)
                                let shellslash = &shellslash
                                try
                                  set noshellslash
                                  return call(a:fn, a:000)
                                finally
                                  let &shellslash = shellslash
                                endtry
                              endfunction
                            
                              " Use utf-8 for fzf.vim commands
                              " Return array of shell commands for cmd.exe
                              function! s:enc_to_cp(str)
                                if !has('iconv')
                                  return a:str
                                endif
                                if !exists('s:codepage')
                                  let s:codepage = libcallnr('kernel32.dll', 'GetACP', 0)
                                endif
                                return iconv(a:str, &encoding, 'cp'.s:codepage)
                              endfunction
                              function! s:wrap_cmds(cmds)
                                return map([
                                  \ '@echo off',
                                  \ 'setlocal enabledelayedexpansion']
                                \ + (has('gui_running') ? ['set TERM= > nul'] : [])
                                \ + (type(a:cmds) == type([]) ? a:cmds : [a:cmds])
                                \ + ['endlocal'],
                                \ '<SID>enc_to_cp(v:val."\r")')
                              endfunction
    1              0.000001 else
    1              0.000001   let s:term_marker = ";#FZF"
                            
    1              0.000002   function! s:fzf_call(fn, ...)
                                return call(a:fn, a:000)
                              endfunction
                            
    1              0.000001   function! s:wrap_cmds(cmds)
                                return a:cmds
                              endfunction
                            
    1              0.000001   function! s:enc_to_cp(str)
                                return a:str
                              endfunction
    1              0.000000 endif
                            
    1              0.000001 function! s:shellesc_cmd(arg)
                              let escaped = substitute(a:arg, '[&|<>()@^]', '^&', 'g')
                              let escaped = substitute(escaped, '%', '%%', 'g')
                              let escaped = substitute(escaped, '"', '\\^&', 'g')
                              let escaped = substitute(escaped, '\(\\\+\)\(\\^\)', '\1\1\2', 'g')
                              return '^"'.substitute(escaped, '\(\\\+\)$', '\1\1', '').'^"'
                            endfunction
                            
    1              0.000001 function! fzf#shellescape(arg, ...)
                              let shell = get(a:000, 0, s:is_win ? 'cmd.exe' : 'sh')
                              if shell =~# 'cmd.exe$'
                                return s:shellesc_cmd(a:arg)
                              endif
                              return s:fzf_call('shellescape', a:arg)
                            endfunction
                            
    1              0.000001 function! s:fzf_getcwd()
                              return s:fzf_call('getcwd')
                            endfunction
                            
    1              0.000001 function! s:fzf_fnamemodify(fname, mods)
                              return s:fzf_call('fnamemodify', a:fname, a:mods)
                            endfunction
                            
    1              0.000001 function! s:fzf_expand(fmt)
                              return s:fzf_call('expand', a:fmt, 1)
                            endfunction
                            
    1              0.000001 function! s:fzf_tempname()
                              return s:fzf_call('tempname')
                            endfunction
                            
    1              0.000003 let s:layout_keys = ['window', 'tmux', 'up', 'down', 'left', 'right']
    1              0.000002 let s:fzf_go = s:base_dir.'/bin/fzf'
    1              0.000002 let s:fzf_tmux = s:base_dir.'/bin/fzf-tmux'
                            
    1              0.000005 let s:cpo_save = &cpo
    1              0.000005 set cpo&vim
                            
    1              0.000001 function! s:popup_support()
                              return has('nvim') ? has('nvim-0.4') : has('popupwin') && has('patch-8.2.191')
                            endfunction
                            
    1              0.000001 function! s:default_layout()
                              return s:popup_support()
                                    \ ? { 'window' : { 'width': 0.9, 'height': 0.6 } }
                                    \ : { 'down': '~40%' }
                            endfunction
                            
    1              0.000001 function! fzf#install()
                              if s:is_win && !has('win32unix')
                                let script = s:base_dir.'/install.ps1'
                                if !filereadable(script)
                                  throw script.' not found'
                                endif
                                let script = 'powershell -ExecutionPolicy Bypass -file ' . script
                              else
                                let script = s:base_dir.'/install'
                                if !executable(script)
                                  throw script.' not found'
                                endif
                                let script .= ' --bin'
                              endif
                            
                              call s:warn('Running fzf installer ...')
                              call system(script)
                              if v:shell_error
                                throw 'Failed to download fzf: '.script
                              endif
                            endfunction
                            
    1              0.000003 let s:versions = {}
    1              0.000002 function s:get_version(bin)
                              if has_key(s:versions, a:bin)
                                return s:versions[a:bin]
                              end
                              let command = a:bin . ' --version --no-height'
                              let output = systemlist(command)
                              if v:shell_error || empty(output)
                                return ''
                              endif
                              let ver = matchstr(output[-1], '[0-9.]\+')
                              let s:versions[a:bin] = ver
                              return ver
                            endfunction
                            
    1              0.000001 function! s:compare_versions(a, b)
                              let a = split(a:a, '\.')
                              let b = split(a:b, '\.')
                              for idx in range(0, max([len(a), len(b)]) - 1)
                                let v1 = str2nr(get(a, idx, 0))
                                let v2 = str2nr(get(b, idx, 0))
                                if     v1 < v2 | return -1
                                elseif v1 > v2 | return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000001 function! s:compare_binary_versions(a, b)
                              return s:compare_versions(s:get_version(a:a), s:get_version(a:b))
                            endfunction
                            
    1              0.000001 let s:checked = {}
    1              0.000001 function! fzf#exec(...)
                              if !exists('s:exec')
                                let binaries = []
                                if executable('fzf')
                                  call add(binaries, 'fzf')
                                endif
                                if executable(s:fzf_go)
                                  call add(binaries, s:fzf_go)
                                endif
                            
                                if empty(binaries)
                                  if input('fzf executable not found. Download binary? (y/n) ') =~? '^y'
                                    redraw
                                    call fzf#install()
                                    return fzf#exec()
                                  else
                                    redraw
                                    throw 'fzf executable not found'
                                  endif
                                elseif len(binaries) > 1
                                  call sort(binaries, 's:compare_binary_versions')
                                endif
                            
                                let s:exec = binaries[-1]
                              endif
                            
                              if a:0 && !has_key(s:checked, a:1)
                                let fzf_version = s:get_version(s:exec)
                                if empty(fzf_version)
                                  let message = printf('Failed to run "%s --version"', s:exec)
                                  unlet s:exec
                                  throw message
                                end
                            
                                if s:compare_versions(fzf_version, a:1) >= 0
                                  let s:checked[a:1] = 1
                                  return s:exec
                                elseif a:0 < 2 && input(printf('You need fzf %s or above. Found: %s. Download binary? (y/n) ', a:1, fzf_version)) =~? '^y'
                                  let s:versions = {}
                                  unlet s:exec
                                  redraw
                                  call fzf#install()
                                  return fzf#exec(a:1, 1)
                                else
                                  throw printf('You need to upgrade fzf (required: %s or above)', a:1)
                                endif
                              endif
                            
                              return s:exec
                            endfunction
                            
    1              0.000003 function! s:tmux_enabled()
                              if has('gui_running') || !exists('$TMUX')
                                return 0
                              endif
                            
                              if exists('s:tmux')
                                return s:tmux
                              endif
                            
                              let s:tmux = 0
                              if !executable(s:fzf_tmux)
                                if executable('fzf-tmux')
                                  let s:fzf_tmux = 'fzf-tmux'
                                else
                                  return 0
                                endif
                              endif
                            
                              let output = system('tmux -V')
                              let s:tmux = !v:shell_error && output >= 'tmux 1.7'
                              return s:tmux
                            endfunction
                            
    1              0.000001 function! s:escape(path)
                              let path = fnameescape(a:path)
                              return s:is_win ? escape(path, '$') : path
                            endfunction
                            
    1              0.000001 function! s:error(msg)
                              echohl ErrorMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:warn(msg)
                              echohl WarningMsg
                              echom a:msg
                              echohl None
                            endfunction
                            
    1              0.000001 function! s:has_any(dict, keys)
                              for key in a:keys
                                if has_key(a:dict, key)
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000001 function! s:open(cmd, target)
                              if stridx('edit', a:cmd) == 0 && s:fzf_fnamemodify(a:target, ':p') ==# s:fzf_expand('%:p')
                                return
                              endif
                              execute a:cmd s:escape(a:target)
                            endfunction
                            
    1              0.000001 function! s:common_sink(action, lines) abort
                              if len(a:lines) < 2
                                return
                              endif
                              let key = remove(a:lines, 0)
                              let Cmd = get(a:action, key, 'e')
                              if type(Cmd) == type(function('call'))
                                return Cmd(a:lines)
                              endif
                              if len(a:lines) > 1
                                augroup fzf_swap
                                  autocmd SwapExists * let v:swapchoice='o'
                                        \| call s:warn('fzf: E325: swap file exists: '.s:fzf_expand('<afile>'))
                                augroup END
                              endif
                              try
                                let empty = empty(s:fzf_expand('%')) && line('$') == 1 && empty(getline(1)) && !&modified
                                " Preserve the current working directory in case it's changed during
                                " the execution (e.g. `set autochdir` or `autocmd BufEnter * lcd ...`)
                                let cwd = exists('w:fzf_pushd') ? w:fzf_pushd.dir : expand('%:p:h')
                                for item in a:lines
                                  if item[0] != '~' && item !~ (s:is_win ? '^[A-Z]:\' : '^/')
                                    let sep = s:is_win ? '\' : '/'
                                    let item = join([cwd, item], cwd[len(cwd)-1] == sep ? '' : sep)
                                  endif
                                  if empty
                                    execute 'e' s:escape(item)
                                    let empty = 0
                                  else
                                    call s:open(Cmd, item)
                                  endif
                                  if !has('patch-8.0.0177') && !has('nvim-0.2') && exists('#BufEnter')
                                        \ && isdirectory(item)
                                    doautocmd BufEnter
                                  endif
                                endfor
                              catch /^Vim:Interrupt$/
                              finally
                                silent! autocmd! fzf_swap
                              endtry
                            endfunction
                            
    1              0.000004 function! s:get_color(attr, ...)
                              let gui = !s:is_win && !has('win32unix') && has('termguicolors') && &termguicolors
                              let fam = gui ? 'gui' : 'cterm'
                              let pat = gui ? '^#[a-f0-9]\+' : '^[0-9]\+$'
                              for group in a:000
                                let code = synIDattr(synIDtrans(hlID(group)), a:attr, fam)
                                if code =~? pat
                                  return code
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000001 function! s:defaults()
                              let rules = copy(get(g:, 'fzf_colors', {}))
                              let colors = join(map(items(filter(map(rules, 'call("s:get_color", v:val)'), '!empty(v:val)')), 'join(v:val, ":")'), ',')
                              return empty(colors) ? '' : fzf#shellescape('--color='.colors)
                            endfunction
                            
    1              0.000001 function! s:validate_layout(layout)
                              for key in keys(a:layout)
                                if index(s:layout_keys, key) < 0
                                  throw printf('Invalid entry in g:fzf_layout: %s (allowed: %s)%s',
                                        \ key, join(s:layout_keys, ', '), key == 'options' ? '. Use $FZF_DEFAULT_OPTS.' : '')
                                endif
                              endfor
                              return a:layout
                            endfunction
                            
    1              0.000001 function! s:evaluate_opts(options)
                              return type(a:options) == type([]) ?
                                    \ join(map(copy(a:options), 'fzf#shellescape(v:val)')) : a:options
                            endfunction
                            
                            " [name string,] [opts dict,] [fullscreen boolean]
    1              0.000001 function! fzf#wrap(...)
                              let args = ['', {}, 0]
                              let expects = map(copy(args), 'type(v:val)')
                              let tidx = 0
                              for arg in copy(a:000)
                                let tidx = index(expects, type(arg) == 6 ? type(0) : type(arg), tidx)
                                if tidx < 0
                                  throw 'Invalid arguments (expected: [name string] [opts dict] [fullscreen boolean])'
                                endif
                                let args[tidx] = arg
                                let tidx += 1
                                unlet arg
                              endfor
                              let [name, opts, bang] = args
                            
                              if len(name)
                                let opts.name = name
                              end
                            
                              " Layout: g:fzf_layout (and deprecated g:fzf_height)
                              if bang
                                for key in s:layout_keys
                                  if has_key(opts, key)
                                    call remove(opts, key)
                                  endif
                                endfor
                              elseif !s:has_any(opts, s:layout_keys)
                                if !exists('g:fzf_layout') && exists('g:fzf_height')
                                  let opts.down = g:fzf_height
                                else
                                  let opts = extend(opts, s:validate_layout(get(g:, 'fzf_layout', s:default_layout())))
                                endif
                              endif
                            
                              " Colors: g:fzf_colors
                              let opts.options = s:defaults() .' '. s:evaluate_opts(get(opts, 'options', ''))
                            
                              " History: g:fzf_history_dir
                              if len(name) && len(get(g:, 'fzf_history_dir', ''))
                                let dir = s:fzf_expand(g:fzf_history_dir)
                                if !isdirectory(dir)
                                  call mkdir(dir, 'p')
                                endif
                                let history = fzf#shellescape(dir.'/'.name)
                                let opts.options = join(['--history', history, opts.options])
                              endif
                            
                              " Action: g:fzf_action
                              if !s:has_any(opts, ['sink', 'sinklist', 'sink*'])
                                let opts._action = get(g:, 'fzf_action', s:default_action)
                                let opts.options .= ' --expect='.join(keys(opts._action), ',')
                                function! opts.sinklist(lines) abort
                                  return s:common_sink(self._action, a:lines)
                                endfunction
                                let opts['sink*'] = opts.sinklist " For backward compatibility
                              endif
                            
                              return opts
                            endfunction
                            
    1              0.000004 function! s:use_sh()
                              let [shell, shellslash, shellcmdflag, shellxquote] = [&shell, &shellslash, &shellcmdflag, &shellxquote]
                              if s:is_win
                                set shell=cmd.exe
                                set noshellslash
                                let &shellcmdflag = has('nvim') ? '/s /c' : '/c'
                                let &shellxquote = has('nvim') ? '"' : '('
                              else
                                set shell=sh
                              endif
                              return [shell, shellslash, shellcmdflag, shellxquote]
                            endfunction
                            
    1              0.000002 function! s:writefile(...)
                              if call('writefile', a:000) == -1
                                throw 'Failed to write temporary file. Check if you can write to the path tempname() returns.'
                              endif
                            endfunction
                            
    1              0.000002 function! fzf#run(...) abort
                            try
                              let [shell, shellslash, shellcmdflag, shellxquote] = s:use_sh()
                            
                              let dict   = exists('a:1') ? copy(a:1) : {}
                              let temps  = { 'result': s:fzf_tempname() }
                              let optstr = s:evaluate_opts(get(dict, 'options', ''))
                              try
                                let fzf_exec = fzf#shellescape(fzf#exec())
                              catch
                                throw v:exception
                              endtry
                            
                              if !s:present(dict, 'dir')
                                let dict.dir = s:fzf_getcwd()
                              endif
                              if has('win32unix') && s:present(dict, 'dir')
                                let dict.dir = fnamemodify(dict.dir, ':p')
                              endif
                            
                              if has_key(dict, 'source')
                                let source = remove(dict, 'source')
                                let type = type(source)
                                if type == 1
                                  let source_command = source
                                elseif type == 3
                                  let temps.input = s:fzf_tempname()
                                  call s:writefile(source, temps.input)
                                  let source_command = (s:is_win ? 'type ' : 'cat ').fzf#shellescape(temps.input)
                                else
                                  throw 'Invalid source type'
                                endif
                              else
                                let source_command = ''
                              endif
                            
                              let prefer_tmux = get(g:, 'fzf_prefer_tmux', 0) || has_key(dict, 'tmux')
                              let use_height = has_key(dict, 'down') && !has('gui_running') &&
                                    \ !(has('nvim') || s:is_win || has('win32unix') || s:present(dict, 'up', 'left', 'right', 'window')) &&
                                    \ executable('tput') && filereadable('/dev/tty')
                              let has_vim8_term = has('terminal') && has('patch-8.0.995')
                              let has_nvim_term = has('nvim-0.2.1') || has('nvim') && !s:is_win
                              let use_term = has_nvim_term ||
                                \ has_vim8_term && !has('win32unix') && (has('gui_running') || s:is_win || s:present(dict, 'down', 'up', 'left', 'right', 'window'))
                              let use_tmux = (has_key(dict, 'tmux') || (!use_height && !use_term || prefer_tmux) && !has('win32unix') && s:splittable(dict)) && s:tmux_enabled()
                              if prefer_tmux && use_tmux
                                let use_height = 0
                                let use_term = 0
                              endif
                              if use_term
                                let optstr .= ' --no-height'
                              elseif use_height
                                let height = s:calc_size(&lines, dict.down, dict)
                                let optstr .= ' --height='.height
                              endif
                              let optstr .= s:border_opt(get(dict, 'window', 0))
                              let prev_default_command = $FZF_DEFAULT_COMMAND
                              if len(source_command)
                                let $FZF_DEFAULT_COMMAND = source_command
                              endif
                              let command = (use_tmux ? s:fzf_tmux(dict) : fzf_exec).' '.optstr.' > '.temps.result
                            
                              if use_term
                                return s:execute_term(dict, command, temps)
                              endif
                            
                              let lines = use_tmux ? s:execute_tmux(dict, command, temps)
                                             \ : s:execute(dict, command, use_height, temps)
                              call s:callback(dict, lines)
                              return lines
                            finally
                              if exists('source_command') && len(source_command)
                                if len(prev_default_command)
                                  let $FZF_DEFAULT_COMMAND = prev_default_command
                                else
                                  let $FZF_DEFAULT_COMMAND = ''
                                  silent! execute 'unlet $FZF_DEFAULT_COMMAND'
                                endif
                              endif
                              let [&shell, &shellslash, &shellcmdflag, &shellxquote] = [shell, shellslash, shellcmdflag, shellxquote]
                            endtry
                            endfunction
                            
    1              0.000004 function! s:present(dict, ...)
                              for key in a:000
                                if !empty(get(a:dict, key, ''))
                                  return 1
                                endif
                              endfor
                              return 0
                            endfunction
                            
    1              0.000002 function! s:fzf_tmux(dict)
                              let size = get(a:dict, 'tmux', '')
                              if empty(size)
                                for o in ['up', 'down', 'left', 'right']
                                  if s:present(a:dict, o)
                                    let spec = a:dict[o]
                                    if (o == 'up' || o == 'down') && spec[0] == '~'
                                      let size = '-'.o[0].s:calc_size(&lines, spec, a:dict)
                                    else
                                      " Legacy boolean option
                                      let size = '-'.o[0].(spec == 1 ? '' : substitute(spec, '^\~', '', ''))
                                    endif
                                    break
                                  endif
                                endfor
                              endif
                              return printf('LINES=%d COLUMNS=%d %s %s - --',
                                \ &lines, &columns, fzf#shellescape(s:fzf_tmux), size)
                            endfunction
                            
    1              0.000001 function! s:splittable(dict)
                              return s:present(a:dict, 'up', 'down') && &lines > 15 ||
                                    \ s:present(a:dict, 'left', 'right') && &columns > 40
                            endfunction
                            
    1              0.000001 function! s:pushd(dict)
                              if s:present(a:dict, 'dir')
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd = {
                                \   'command': haslocaldir() ? 'lcd' : (exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd'),
                                \   'origin': cwd,
                                \   'bufname': bufname('')
                                \ }
                                execute 'lcd' s:escape(a:dict.dir)
                                let cwd = s:fzf_getcwd()
                                let w:fzf_pushd.dir = cwd
                                let a:dict.pushd = w:fzf_pushd
                                return cwd
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 augroup fzf_popd
    1              0.000038   autocmd!
    1              0.000007   autocmd WinEnter * call s:dopopd()
    1              0.000001 augroup END
                            
    1              0.000001 function! s:dopopd()
                              if !exists('w:fzf_pushd')
                                return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet! w:fzf_pushd
                            endfunction
                            
    1              0.000001 function! s:xterm_launcher()
                              let fmt = 'xterm -T "[fzf]" -bg "%s" -fg "%s" -geometry %dx%d+%d+%d -e bash -ic %%s'
                              if has('gui_macvim')
                                let fmt .= '&& osascript -e "tell application \"MacVim\" to activate"'
                              endif
                              return printf(fmt,
                                \ escape(synIDattr(hlID("Normal"), "bg"), '#'), escape(synIDattr(hlID("Normal"), "fg"), '#'),
                                \ &columns, &lines/2, getwinposx(), getwinposy())
                            endfunction
    1              0.000001 unlet! s:launcher
    1              0.000005 if s:is_win || has('win32unix')
                              let s:launcher = '%s'
    1              0.000001 else
    1              0.000005   let s:launcher = function('s:xterm_launcher')
    1              0.000001 endif
                            
    1              0.000001 function! s:exit_handler(code, command, ...)
                              if a:code == 130
                                return 0
                              elseif has('nvim') && a:code == 129
                                " When deleting the terminal buffer while fzf is still running,
                                " Nvim sends SIGHUP.
                                return 0
                              elseif a:code > 1
                                call s:error('Error running ' . a:command)
                                if !empty(a:000)
                                  sleep
                                endif
                                return 0
                              endif
                              return 1
                            endfunction
                            
    1              0.000002 function! s:execute(dict, command, use_height, temps) abort
                              call s:pushd(a:dict)
                              if has('unix') && !a:use_height
                                silent! !clear 2> /dev/null
                              endif
                              let escaped = (a:use_height || s:is_win) ? a:command : escape(substitute(a:command, '\n', '\\n', 'g'), '%#!')
                              if has('gui_running')
                                let Launcher = get(a:dict, 'launcher', get(g:, 'Fzf_launcher', get(g:, 'fzf_launcher', s:launcher)))
                                let fmt = type(Launcher) == 2 ? call(Launcher, []) : Launcher
                                if has('unix')
                                  let escaped = "'".substitute(escaped, "'", "'\"'\"'", 'g')."'"
                                endif
                                let command = printf(fmt, escaped)
                              else
                                let command = escaped
                              endif
                              if s:is_win
                                let batchfile = s:fzf_tempname().'.bat'
                                call s:writefile(s:wrap_cmds(command), batchfile)
                                let command = batchfile
                                let a:temps.batchfile = batchfile
                                if has('nvim')
                                  let fzf = {}
                                  let fzf.dict = a:dict
                                  let fzf.temps = a:temps
                                  function! fzf.on_exit(job_id, exit_status, event) dict
                                    call s:pushd(self.dict)
                                    let lines = s:collect(self.temps)
                                    call s:callback(self.dict, lines)
                                  endfunction
                                  let cmd = 'start /wait cmd /c '.command
                                  call jobstart(cmd, fzf)
                                  return []
                                endif
                              elseif has('win32unix') && $TERM !=# 'cygwin'
                                let shellscript = s:fzf_tempname()
                                call s:writefile([command], shellscript)
                                let command = 'cmd.exe /C '.fzf#shellescape('set "TERM=" & start /WAIT sh -c '.shellscript)
                                let a:temps.shellscript = shellscript
                              endif
                              if a:use_height
                                call system(printf('tput cup %d > /dev/tty; tput cnorm > /dev/tty; %s < /dev/tty 2> /dev/tty', &lines, command))
                              else
                                execute 'silent !'.command
                              endif
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
    1              0.000002 function! s:execute_tmux(dict, command, temps) abort
                              let command = a:command
                              let cwd = s:pushd(a:dict)
                              if len(cwd)
                                " -c '#{pane_current_path}' is only available on tmux 1.9 or above
                                let command = join(['cd', fzf#shellescape(cwd), '&&', command])
                              endif
                            
                              call system(command)
                              let exit_status = v:shell_error
                              redraw!
                              let lines = s:collect(a:temps)
                              return s:exit_handler(exit_status, command) ? lines : []
                            endfunction
                            
    1              0.000002 function! s:calc_size(max, val, dict)
                              let val = substitute(a:val, '^\~', '', '')
                              if val =~ '%$'
                                let size = a:max * str2nr(val[:-2]) / 100
                              else
                                let size = min([a:max, str2nr(val)])
                              endif
                            
                              let srcsz = -1
                              if type(get(a:dict, 'source', 0)) == type([])
                                let srcsz = len(a:dict.source)
                              endif
                            
                              let opts = $FZF_DEFAULT_OPTS.' '.s:evaluate_opts(get(a:dict, 'options', ''))
                              if opts =~ 'preview'
                                return size
                              endif
                              let margin = match(opts, '--inline-info\|--info[^-]\{-}inline') > match(opts, '--no-inline-info\|--info[^-]\{-}\(default\|hidden\)') ? 1 : 2
                              let margin += stridx(opts, '--border') > stridx(opts, '--no-border') ? 2 : 0
                              if stridx(opts, '--header') > stridx(opts, '--no-header')
                                let margin += len(split(opts, "\n"))
                              endif
                              return srcsz >= 0 ? min([srcsz + margin, size]) : size
                            endfunction
                            
    1              0.000001 function! s:getpos()
                              return {'tab': tabpagenr(), 'win': winnr(), 'winid': win_getid(), 'cnt': winnr('$'), 'tcnt': tabpagenr('$')}
                            endfunction
                            
    1              0.000001 function! s:border_opt(window)
                              if type(a:window) != type({})
                                return ''
                              endif
                            
                              " Border style
                              let style = tolower(get(a:window, 'border', 'rounded'))
                              if !has_key(a:window, 'border') && !get(a:window, 'rounded', 1)
                                let style = 'sharp'
                              endif
                              if style == 'none' || style == 'no'
                                return ''
                              endif
                            
                              " For --border styles, we need fzf 0.24.0 or above
                              call fzf#exec('0.24.0')
                              let opt = ' --border=' . style
                              if has_key(a:window, 'highlight')
                                let color = s:get_color('fg', a:window.highlight)
                                if len(color)
                                  let opt .= ' --color=border:' . color
                                endif
                              endif
                              return opt
                            endfunction
                            
    1              0.000001 function! s:split(dict)
                              let directions = {
                              \ 'up':    ['topleft', 'resize', &lines],
                              \ 'down':  ['botright', 'resize', &lines],
                              \ 'left':  ['vertical topleft', 'vertical resize', &columns],
                              \ 'right': ['vertical botright', 'vertical resize', &columns] }
                              let ppos = s:getpos()
                              let is_popup = 0
                              try
                                if s:present(a:dict, 'window')
                                  if type(a:dict.window) == type({})
                                    if !s:popup_support()
                                      throw 'Nvim 0.4+ or Vim 8.2.191+ with popupwin feature is required for pop-up window'
                                    end
                                    call s:popup(a:dict.window)
                                    let is_popup = 1
                                  else
                                    execute 'keepalt' a:dict.window
                                  endif
                                elseif !s:splittable(a:dict)
                                  execute (tabpagenr()-1).'tabnew'
                                else
                                  for [dir, triple] in items(directions)
                                    let val = get(a:dict, dir, '')
                                    if !empty(val)
                                      let [cmd, resz, max] = triple
                                      if (dir == 'up' || dir == 'down') && val[0] == '~'
                                        let sz = s:calc_size(max, val, a:dict)
                                      else
                                        let sz = s:calc_size(max, val, {})
                                      endif
                                      execute cmd sz.'new'
                                      execute resz sz
                                      return [ppos, {}, is_popup]
                                    endif
                                  endfor
                                endif
                                return [ppos, is_popup ? {} : { '&l:wfw': &l:wfw, '&l:wfh': &l:wfh }, is_popup]
                              finally
                                if !is_popup
                                  setlocal winfixwidth winfixheight
                                endif
                              endtry
                            endfunction
                            
    1              0.000008 nnoremap <silent> <Plug>(fzf-insert) i
    1              0.000004 nnoremap <silent> <Plug>(fzf-normal) <Nop>
    1              0.000002 if exists(':tnoremap')
    1              0.000005   tnoremap <silent> <Plug>(fzf-insert) <C-\><C-n>i
    1              0.000003   tnoremap <silent> <Plug>(fzf-normal) <C-\><C-n>
    1              0.000001 endif
                            
    1              0.000001 function! s:execute_term(dict, command, temps) abort
                              let winrest = winrestcmd()
                              let pbuf = bufnr('')
                              let [ppos, winopts, is_popup] = s:split(a:dict)
                              call s:use_sh()
                              let b:fzf = a:dict
                              let fzf = { 'buf': bufnr(''), 'pbuf': pbuf, 'ppos': ppos, 'dict': a:dict, 'temps': a:temps,
                                        \ 'winopts': winopts, 'winrest': winrest, 'lines': &lines,
                                        \ 'columns': &columns, 'command': a:command }
                              function! fzf.switch_back(inplace)
                                if a:inplace && bufnr('') == self.buf
                                  if bufexists(self.pbuf)
                                    execute 'keepalt keepjumps b' self.pbuf
                                  endif
                                  " No other listed buffer
                                  if bufnr('') == self.buf
                                    enew
                                  endif
                                endif
                              endfunction
                              function! fzf.on_exit(id, code, ...)
                                if s:getpos() == self.ppos " {'window': 'enew'}
                                  for [opt, val] in items(self.winopts)
                                    execute 'let' opt '=' val
                                  endfor
                                  call self.switch_back(1)
                                else
                                  if bufnr('') == self.buf
                                    " We use close instead of bd! since Vim does not close the split when
                                    " there's no other listed buffer (nvim +'set nobuflisted')
                                    close
                                  endif
                                  silent! execute 'tabnext' self.ppos.tab
                                  silent! execute self.ppos.win.'wincmd w'
                                endif
                            
                                if bufexists(self.buf)
                                  execute 'bd!' self.buf
                                endif
                            
                                if &lines == self.lines && &columns == self.columns && s:getpos() == self.ppos
                                  execute self.winrest
                                endif
                            
                                let lines = s:collect(self.temps)
                                if !s:exit_handler(a:code, self.command, 1)
                                  return
                                endif
                            
                                call s:pushd(self.dict)
                                call s:callback(self.dict, lines)
                                call self.switch_back(s:getpos() == self.ppos)
                            
                                if &buftype == 'terminal'
                                  call feedkeys(&filetype == 'fzf' ? "\<Plug>(fzf-insert)" : "\<Plug>(fzf-normal)")
                                endif
                              endfunction
                            
                              try
                                call s:pushd(a:dict)
                                if s:is_win
                                  let fzf.temps.batchfile = s:fzf_tempname().'.bat'
                                  call s:writefile(s:wrap_cmds(a:command), fzf.temps.batchfile)
                                  let command = fzf.temps.batchfile
                                else
                                  let command = a:command
                                endif
                                let command .= s:term_marker
                                if has('nvim')
                                  call termopen(command, fzf)
                                else
                                  let term_opts = {'exit_cb': function(fzf.on_exit)}
                                  if v:version >= 802
                                    let term_opts.term_kill = 'term'
                                  endif
                                  if is_popup
                                    let term_opts.hidden = 1
                                  else
                                    let term_opts.curwin = 1
                                  endif
                                  let fzf.buf = term_start([&shell, &shellcmdflag, command], term_opts)
                                  if is_popup && exists('#TerminalWinOpen')
                                    doautocmd <nomodeline> TerminalWinOpen
                                  endif
                                  if !has('patch-8.0.1261') && !s:is_win
                                    call term_wait(fzf.buf, 20)
                                  endif
                                endif
                                tnoremap <buffer> <c-z> <nop>
                                if exists('&termwinkey') && (empty(&termwinkey) || &termwinkey =~? '<c-w>')
                                  tnoremap <buffer> <c-w> <c-w>.
                                endif
                              finally
                                call s:dopopd()
                              endtry
                              setlocal nospell bufhidden=wipe nobuflisted nonumber
                              setf fzf
                              startinsert
                              return []
                            endfunction
                            
    1              0.000001 function! s:collect(temps) abort
                              try
                                return filereadable(a:temps.result) ? readfile(a:temps.result) : []
                              finally
                                for tf in values(a:temps)
                                  silent! call delete(tf)
                                endfor
                              endtry
                            endfunction
                            
    1              0.000001 function! s:callback(dict, lines) abort
                              let popd = has_key(a:dict, 'pushd')
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                              endif
                            
                              try
                                if has_key(a:dict, 'sink')
                                  for line in a:lines
                                    if type(a:dict.sink) == 2
                                      call a:dict.sink(line)
                                    else
                                      execute a:dict.sink s:escape(line)
                                    endif
                                  endfor
                                endif
                                if has_key(a:dict, 'sink*')
                                  call a:dict['sink*'](a:lines)
                                elseif has_key(a:dict, 'sinklist')
                                  call a:dict['sinklist'](a:lines)
                                endif
                              catch
                                if stridx(v:exception, ':E325:') < 0
                                  echoerr v:exception
                                endif
                              endtry
                            
                              " We may have opened a new window or tab
                              if popd
                                let w:fzf_pushd = a:dict.pushd
                                call s:dopopd()
                              endif
                            endfunction
                            
    1              0.000002 if has('nvim')
    1              0.000001   function s:create_popup(hl, opts) abort
                                let buf = nvim_create_buf(v:false, v:true)
                                let opts = extend({'relative': 'editor', 'style': 'minimal'}, a:opts)
                                let win = nvim_open_win(buf, v:true, opts)
                                call setwinvar(win, '&winhighlight', 'NormalFloat:'..a:hl)
                                call setwinvar(win, '&colorcolumn', '')
                                return buf
                              endfunction
                            else
                              function! s:create_popup(hl, opts) abort
                                let s:popup_create = {buf -> popup_create(buf, #{
                                  \ line: a:opts.row,
                                  \ col: a:opts.col,
                                  \ minwidth: a:opts.width,
                                  \ maxwidth: a:opts.width,
                                  \ minheight: a:opts.height,
                                  \ maxheight: a:opts.height,
                                  \ zindex: 1000,
                                \ })}
                                autocmd TerminalOpen * ++once call s:popup_create(str2nr(expand('<abuf>')))
                              endfunction
    1              0.000001 endif
                            
    1              0.000001 function! s:popup(opts) abort
                              let xoffset = get(a:opts, 'xoffset', 0.5)
                              let yoffset = get(a:opts, 'yoffset', 0.5)
                              let relative = get(a:opts, 'relative', 0)
                            
                              " Use current window size for positioning relatively positioned popups
                              let columns = relative ? winwidth(0) : &columns
                              let lines = relative ? winheight(0) : (&lines - has('nvim'))
                            
                              " Size and position
                              let width = min([max([8, a:opts.width > 1 ? a:opts.width : float2nr(columns * a:opts.width)]), columns])
                              let height = min([max([4, a:opts.height > 1 ? a:opts.height : float2nr(lines * a:opts.height)]), lines])
                              let row = float2nr(yoffset * (lines - height)) + (relative ? win_screenpos(0)[0] - 1 : 0)
                              let col = float2nr(xoffset * (columns - width)) + (relative ? win_screenpos(0)[1] - 1 : 0)
                            
                              " Managing the differences
                              let row = min([max([0, row]), &lines - has('nvim') - height])
                              let col = min([max([0, col]), &columns - width])
                              let row += !has('nvim')
                              let col += !has('nvim')
                            
                              call s:create_popup('Normal', {
                                \ 'row': row, 'col': col, 'width': width, 'height': height
                              \ })
                            endfunction
                            
    1              0.000005 let s:default_action = {
                              \ 'ctrl-t': 'tab split',
                              \ 'ctrl-x': 'split',
                              \ 'ctrl-v': 'vsplit' }
                            
    1              0.000001 function! s:shortpath()
                              let short = fnamemodify(getcwd(), ':~:.')
                              if !has('win32unix')
                                let short = pathshorten(short)
                              endif
                              let slash = (s:is_win && !&shellslash) ? '\' : '/'
                              return empty(short) ? '~'.slash : short . (short =~ escape(slash, '\').'$' ? '' : slash)
                            endfunction
                            
    1              0.000001 function! s:cmd(bang, ...) abort
                              let args = copy(a:000)
                              let opts = { 'options': ['--multi'] }
                              if len(args) && isdirectory(expand(args[-1]))
                                let opts.dir = substitute(substitute(remove(args, -1), '\\\(["'']\)', '\1', 'g'), '[/\\]*$', '/', '')
                                if s:is_win && !&shellslash
                                  let opts.dir = substitute(opts.dir, '/', '\\', 'g')
                                endif
                                let prompt = opts.dir
                              else
                                let prompt = s:shortpath()
                              endif
                              let prompt = strwidth(prompt) < &columns - 20 ? prompt : '> '
                              call extend(opts.options, ['--prompt', prompt])
                              call extend(opts.options, args)
                              call fzf#run(fzf#wrap('FZF', opts, a:bang))
                            endfunction
                            
    1              0.000006 command! -nargs=* -complete=dir -bang FZF call s:cmd(<bang>0, <f-args>)
                            
    1              0.000006 let &cpo = s:cpo_save
    1              0.000003 unlet s:cpo_save

SCRIPT  /Users/mochi/.local/share/nvim/plugged/glyph-palette.vim/plugin/glyph_palette.vim
Sourced 1 time
Total time:   0.001098
 Self time:   0.000408

count  total (s)   self (s)
    1              0.000009 if exists('g:loaded_glyph_palette')
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_glyph_palette = 1
                            
    1              0.000003 if !get(g:, 'glyph_palette_disable_default_colors')
    1   0.000793   0.000102   call glyph_palette#defaults#highlight()
    1              0.000004 endif

SCRIPT  /Users/mochi/.local/share/nvim/plugged/fern-hijack.vim/plugin/fern_hijack.vim
Sourced 1 time
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
    1              0.000014 if exists('g:loaded_fern_hijack') || ( !has('nvim') && v:version < 801 )
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_fern_hijack = 1
                            
    1              0.000004 function! s:hijack_directory() abort
                              let path = s:expand('%:p')
                              if !isdirectory(path)
                                return
                              endif
                              let bufnr = bufnr()
                              execute printf('keepjumps keepalt Fern %s', fnameescape(path))
                              execute printf('silent! bwipeout %d', bufnr)
                            endfunction
                            
    1              0.000001 function! s:suppress_netrw() abort
                              if exists('#FileExplorer')
                                autocmd! FileExplorer *
                              endif
                            endfunction
                            
    1              0.000001 function! s:expand(expr) abort
                              try
                                return fern#util#expand(a:expr)
                              catch /^Vim\%((\a\+)\)\=:E117:/
                                return expand(a:expr)
                              endtry
                            endfunction
                            
    1              0.000002 augroup fern-hijack
    1              0.000038   autocmd!
    1              0.000005   autocmd VimEnter * call s:suppress_netrw()
    1              0.000002   autocmd BufEnter * ++nested call s:hijack_directory()
    1              0.000003 augroup END

SCRIPT  /Users/mochi/.local/share/nvim/plugged/vim-auto-save/plugin/AutoSave.vim
Sourced 1 time
Total time:   0.000420
 Self time:   0.000420

count  total (s)   self (s)
                            "======================================
                            "    Script Name:  vim-auto-save (http://www.vim.org/scripts/script.php?script_id=4521)
                            "    Plugin Name:  AutoSave
                            "        Version:  0.1.7
                            "======================================
                            
    1              0.000007 if exists("g:auto_save_loaded")
                              finish
    1              0.000001 else
    1              0.000003   let g:auto_save_loaded = 1
    1              0.000001 endif
                            
    1              0.000017 let s:save_cpo = &cpo
    1              0.000007 set cpo&vim
                            
    1              0.000004 if !exists("g:auto_save")
                              let g:auto_save = 0
    1              0.000001 endif
                            
    1              0.000002 if !exists("g:auto_save_no_updatetime")
    1              0.000002   let g:auto_save_no_updatetime = 0
    1              0.000001 endif
                            
    1              0.000002 if !exists("g:auto_save_in_insert_mode")
    1              0.000001   let g:auto_save_in_insert_mode = 1
    1              0.000000 endif
                            
    1              0.000001 if g:auto_save_no_updatetime == 0
    1              0.000003   set updatetime=200
    1              0.000000 endif
                            
    1              0.000001 if !exists("g:auto_save_silent")
    1              0.000001   let g:auto_save_silent = 0
    1              0.000000 endif
                            
    1              0.000002 augroup auto_save
    1              0.000041   autocmd!
    1              0.000001   if g:auto_save_in_insert_mode == 1
    1              0.000008     au CursorHoldI,CompleteDone * nested call AutoSave()
    1              0.000001   endif
    1              0.000004   au CursorHold,InsertLeave * nested call AutoSave()
    1              0.000001 augroup END
                            
    1              0.000003 command! AutoSaveToggle :call AutoSaveToggle()
                            
    1              0.000002 function! AutoSave()
                              if g:auto_save >= 1
                                let was_modified = &modified
                                silent! wa
                                if was_modified && !&modified
                                  if exists("g:auto_save_postsave_hook")
                                    execute "" . g:auto_save_postsave_hook
                                  endif
                                  if g:auto_save_silent == 0
                                    echo "(AutoSaved at " . strftime("%H:%M:%S") . ")"
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000001 function! AutoSaveToggle()
                              if g:auto_save >= 1
                                let g:auto_save = 0
                                echo "AutoSave is OFF"
                              else
                                let g:auto_save = 1
                                echo "AutoSave is ON"
                              endif
                            endfunction
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /Users/mochi/.local/share/nvim/plugged/denops.vim/plugin/denops.vim
Sourced 1 time
Total time:   0.001039
 Self time:   0.000547

count  total (s)   self (s)
    1              0.000009 if exists('g:loaded_denops')
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_denops = 1
                            
    1              0.000007 if !get(g:, 'denops_disable_version_check') && !has('nvim-0.6.0') && !has('patch-8.2.3452')
                              echohl WarningMsg
                              echo '[denops] Denops requires Vim 8.2.3452 or Neovim 0.6.0. See ":h g:denops_disable_version_check" to disable this check.'
                              echohl None
                              finish
    1              0.000000 endif
                            
    1   0.000650   0.000158 if !executable(g:denops#deno)
                              echohl WarningMsg
                              echo printf("[denops] A '%s' (g:denops#deno) is not executable. Denops requires executable Deno.", g:denops#deno)
                              echohl None
                              finish
    1              0.000001 endif
                            
    1              0.000002 augroup denops_plugin_internal
    1              0.000041   autocmd!
    1              0.000012   autocmd User DenopsReady call denops#plugin#discover()
    1              0.000004   autocmd User DenopsPluginPre:* :
    1              0.000003   autocmd User DenopsPluginPost:* :
    1              0.000001 augroup END
                            
    1              0.000003 if has('vim_starting')
    1              0.000001   augroup denops_plugin_internal_startup
    1              0.000019     autocmd!
    1              0.000004     autocmd VimEnter * call denops#server#start()
    1              0.000001   augroup END
                            else
                              call denops#server#start()
    1              0.000003 endif

SCRIPT  /Users/mochi/.local/share/nvim/plugged/vim-closetag/plugin/closetag.vim
Sourced 1 time
Total time:   0.001098
 Self time:   0.000854

count  total (s)   self (s)
                            " {{{
                            "
                            "      Modifier:  Alvan
                            "   Description:  Auto close tag.
                            "                 Based on xml.vim(http://www.vim.org/scripts/script.php?script_id=1397)
                            "
                            " }}}
                            "
    1              0.000013 if exists("g:loaded_closetag") | fini | en | let g:loaded_closetag = "1.8.11"
                            
    1              0.000004 fun! s:Initial()
                                call s:Declare('g:closetag_filetypes', 'html,xhtml,phtml')
                                call s:Declare('g:closetag_xhtml_filetypes', 'xhtml')
                            
                                call s:Declare('g:closetag_filenames', '*.html,*.xhtml,*.phtml')
                                call s:Declare('g:closetag_xhtml_filenames', '*.xhtml')
                            
                                call s:Declare('g:closetag_shortcut', '>')
                                call s:Declare('g:closetag_close_shortcut', '')
                            
                                call s:Declare('g:closetag_emptyTags_caseSensitive', 0)
                            
                                call s:Declare('g:closetag_regions', {
                                    \ 'typescript.tsx': 'jsxRegion,tsxRegion',
                                    \ 'javascript.jsx': 'jsxRegion',
                                    \ 'typescriptreact': 'jsxRegion,tsxRegion',
                                    \ 'javascriptreact': 'jsxRegion',
                                    \ })
                            
                                let g:closetag_filenames = substitute(g:closetag_filenames, '\s*,\s\+', ',', 'g')
                                let g:closetag_xhtml_filenames = substitute(g:closetag_xhtml_filenames, '\s*,\s\+', ',', 'g')
                                let g:closetag_filetypes = substitute(g:closetag_filetypes, '\s*,\s\+', ',', 'g')
                                let g:closetag_xhtml_filetypes = substitute(g:closetag_xhtml_filetypes, '\s*,\s\+', ',', 'g')
                            
                                if g:closetag_shortcut != ''
                                    exec "au User vim-closetag inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
                            
                                    if g:closetag_filetypes != ''
                                        exec "au FileType " . g:closetag_filetypes . " inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
                                    en
                                    if g:closetag_filenames != ''
                                        exec "au BufNewFile,Bufread " . g:closetag_filenames . " inoremap <silent> <buffer> " . g:closetag_shortcut . " ><Esc>:call <SID>CloseIt()<Cr>"
                                    en
                                en
                            
                                if g:closetag_close_shortcut != ''
                                    if g:closetag_filetypes != ''
                                        exec "au FileType " . g:closetag_filetypes . " inoremap <silent> <buffer> " . g:closetag_close_shortcut . " >"
                                    en
                                    if g:closetag_filenames != ''
                                        exec "au BufNewFile,Bufread " . g:closetag_filenames . " inoremap <silent> <buffer> " . g:closetag_close_shortcut . " >"
                                    en
                                en
                            
                                if g:closetag_xhtml_filetypes != ''
                                    exec "au FileType " . g:closetag_xhtml_filetypes . " call <SID>Declare('b:closetag_use_xhtml', 1)"
                                en
                                if g:closetag_xhtml_filenames != ''
                                    exec "au BufNewFile,Bufread " . g:closetag_xhtml_filenames . " call <SID>Declare('b:closetag_use_xhtml', 1)"
                                en
                            
                                com! -nargs=* -complete=file CloseTagEnableBuffer let b:closetag_disabled = 0
                                com! -nargs=* -complete=file CloseTagDisableBuffer let b:closetag_disabled = 1
                                com! -nargs=* -complete=file CloseTagToggleBuffer let b:closetag_disabled = exists('b:closetag_disabled') && b:closetag_disabled ? 0 : 1
                            
                                " Script rgular expresion used. Documents those nasty criters
                                " Don't check for quotes around attributes!!!
                                let s:ReqAttrib = '\(\(\s\|\n\)\+\([^>= \t]\+=[^>&]\+\)\(\s\|\n\)*\)\+\(\/\)\@\<!>'
                                let s:EndofName = '\($\|\s\|>\)'
                            endf
                            
                            " Define default variables
    1              0.000002 fun! s:Declare(var, def)
                                if !exists(a:var)
                                    let {a:var} = a:def
                                en
                            endf
                            
                            " Buffer variables
    1              0.000001 fun! s:InitBuf()
                                call s:Declare('b:did_ftplugin_closetag', 1)
                                call s:Declare('b:closetag_emptyTags', '^\(area\|base\|br\|col\|command\|embed\|hr\|img\|input\|keygen\|link\|meta\|param\|source\|track\|wbr\)$')
                                call s:Declare('b:closetag_firstWasEndTag', 0)
                                call s:Declare('b:closetag_html_mode', 1)
                                call s:Declare('b:closetag_haveAtt', 0)
                                call s:Declare('b:closetag_use_xhtml', &filetype == 'xhtml' ? 1 : 0)
                            endf
                            
    1              0.000001 fun! s:SavePos()
                                retu 'call cursor('.line('.').','. col('.'). ')'
                            endf
                            
    1              0.000001 fun! s:Handler(xml_tag, isHtml)
                                let text = 0
                                if a:isHtml == 1 && exists("*HtmlAttribCallback")
                                    let text = HtmlAttribCallback(a:xml_tag)
                                elseif exists("*XmlAttribCallback")
                                    let text = XmlAttribCallback(a:xml_tag)
                                en
                                if text != '0'
                                    execute "normal! i " . text ."\<Esc>l"
                                en
                            endf
                            
                            " Gets the tagname from start position.
                            "
                            " Now lets go for the name part. The namepart are xmlnamechars which
                            " is quite a big range. We assume that everything after '<' or '</'
                            " until the first 'space', 'forward slash' or '>' ends de name part.
    1              0.000007 fun! s:TagName(from)
                                let l:end = match(getline('.'), s:EndofName,a:from)
                                let l:tag = strpart(getline('.'),a:from, l:end - a:from)
                                if strridx(l:tag, "\\") == strlen(l:tag) - 1
                                    let l:tag = ''
                                en
                            
                                retu l:tag
                            endf
                            
                            " Looks for attribute in open tag
                            " expect cursor to be on <
    1              0.000001 fun! s:HaveAtt()
                                "Check if this open tag has attributes
                                let l:line = line('.') | let l:col = col('.')
                                if search(b:closetag_tagName . s:ReqAttrib,'W') > 0
                                    if l:line == line('.') && l:col == (col('.')-1)
                                        let b:closetag_haveAtt = 1
                                    en
                                en
                            endf
                            
                            " Should the tag be treated as an non closing) tag?
                            " check the current tag with the set of tags defined in b:closetag_emptyTags
                            " closetag_emptyTags_caseSensitive defines if the check is case sensitive
    1              0.000001 fun! s:AsEmpty()
                                retu g:closetag_emptyTags_caseSensitive == 1
                                            \ ? b:closetag_tagName =~# b:closetag_emptyTags
                                            \ : b:closetag_tagName =~? b:closetag_emptyTags
                            endf
                            
                            " Is there a tag under the cursor?
                            " Set bufer wide variable
                            "  - b:closetag_firstWasEndTag
                            "  - b:closetag_tagName
                            "  - b:gotoCloseTag (if the tag under the cursor is one)
                            "  - b:gotoOpenTag  (if the tag under the cursor is one)
                            " on exit
                            "    - returns 1 (true)  or 0 (false)
                            "    - position is at '<'
    1              0.000001 fun! s:FindTag()
                                let b:closetag_firstWasEndTag = 0
                                let b:closetag_haveAtt = 0
                                let l:haveTag = 0
                                let l:stayCol = col('.')
                            
                                "Lets find forward a < or a >.  If we first find a > we might be in a tag.
                                "If we find a < first or nothing we are definitly not in a tag
                            
                                " if getline('.')[col('.') - 1] != '>'
                                " search('[<>]','W')
                                " en
                            
                                if getline('.')[col('.') - 1] == '>'
                                    " we don't work with:
                                    " blank string, empty tags, jsp %> tags, php ?> tags, operator =>, operator ->
                                    if index([' ', '/', '%', '?', '=', '-'], getline('.')[col('.')-2]) >= 0
                                        retu l:haveTag
                                    en
                                el
                                    retu l:haveTag
                                en
                            
                                if search('[<>]','bW') >=0
                                    if getline('.')[col('.')-1] == '<'
                                        if getline('.')[col('.')] == '/'
                                            let b:closetag_firstWasEndTag = 1
                                            let b:gotoCloseTag = s:SavePos()
                                        elseif getline('.')[col('.')] == '?' ||  getline('.')[col('.')] == '!'
                                            "we don't deal with processing instructions or dtd
                                            "related definitions
                                            retu l:haveTag
                                        el
                                            let b:gotoOpenTag = s:SavePos()
                                        en
                                    el
                                        retu l:haveTag
                                    en
                                el
                                    retu l:haveTag
                                en
                            
                                "we don't deal with the first > in quotes
                                let l:str = strpart(getline('.'),col('.'), l:stayCol - col('.'))
                                if (strlen(l:str) - strlen(substitute(substitute(substitute(l:str, '\\\\', '', 'g'), '\\"', '', 'g'), '"', '', 'g'))) % 2
                                    retu l:haveTag
                                en
                            
                                "we have established that we are between something like
                                "'</\?[^>]*>'
                            
                                let b:closetag_tagName = s:TagName(col('.') + b:closetag_firstWasEndTag)
                                "echo 'Tag ' . b:closetag_tagName
                            
                                "begin: gwang customization, do not work with an empty tag name
                                if b:closetag_tagName == ''
                                    retu l:haveTag
                                en
                                "end: gwang customization, do not work with an empty tag name
                            
                                let l:haveTag = 1
                                if b:closetag_firstWasEndTag == 0
                                    call s:HaveAtt()
                                    if exists('b:gotoOpenTag') && b:gotoOpenTag != ''
                                        exe b:gotoOpenTag
                                    en
                                en
                                retu l:haveTag
                            endf
                            
    1              0.000001 fun! s:InValidRegion()
                                let l:regions = get(g:closetag_regions, &filetype, '')
                                if l:regions == ''
                                    " no restrictions? no problem
                                    return 1
                                en
                            
                                " make sure we're in a valid region type
                                let l:regionStack = synstack(line('.'), col('.'))
                                for id in l:regionStack
                                    let l:regionName = synIDattr(id, "name")
                                    if stridx(l:regions, l:regionName) != -1
                                        retu 1
                                    en
                                endfor
                            
                                " not in a valid region; cancel
                                retu 0
                            endf
                            
    1              0.000003 fun! s:CloseIt()
                                if !exists("b:did_ftplugin_closetag")
                                    call s:InitBuf()
                                en
                            
                                if !(exists("b:closetag_disabled") && b:closetag_disabled) && s:InValidRegion()
                                    let l:restore = s:SavePos()
                            
                                    let l:endOfLine = ((col('.')+1) == col('$'))
                                    if col('.') > 1 && getline('.')[col('.')-2] == '>'
                                        let l:line = line('.')
                                        "Multiline request. <t>></t> -->
                                        "<t>
                                        "        cursor comes here
                                        "</t>
                                        normal! h
                                        if s:FindTag()
                                            if b:closetag_firstWasEndTag == 0
                                                if l:line > 0 && l:line != line('.')
                                                    exe "normal! " . l:line . "gg"
                                                en
                                                if exists('b:did_indent') && b:did_indent == 1
                                                    exe "normal! 2f>a\<Cr>\<Esc>k$i\<Cr>\<Esc>$"
                                                else
                                                    exe "normal! 2f>a\<Cr>\<Esc>k$i\<Cr>\<Esc>>>$"
                                                en
                                                call setline('.', strpart(getline('.'), 0, strlen(getline('.'))-1))
                            
                                                if col('.') >= col('$') | start | el | start! | en
                                                retu
                                            en
                                        en
                                    elseif s:FindTag()
                                        if b:closetag_firstWasEndTag == 0
                                            exe "silent normal! />\<Cr>"
                                            if b:closetag_html_mode && s:AsEmpty()
                                                if b:closetag_haveAtt == 0
                                                    call s:Handler(b:closetag_tagName, b:closetag_html_mode)
                                                en
                                                if b:closetag_use_xhtml
                                                    exe "normal! i/\<Esc>l"
                                                en
                                                if l:endOfLine
                                                    start!
                                                    retu
                                                el
                                                    normal! l
                                                    start
                                                    retu
                                                en
                                            el
                                                if b:closetag_haveAtt == 0
                                                    call s:Handler(b:closetag_tagName, b:closetag_html_mode)
                                                en
                                                exe "normal! a</" . b:closetag_tagName . ">\<Esc>F<"
                                                start
                                                retu
                                            en
                                        en
                                    en
                                    exe l:restore
                                en
                            
                                if (col('.')+1) == col("$")
                                    startinsert!
                                else
                                    normal! l
                                    startinsert
                                en
                            endf
                            
    1   0.000254   0.000011 call s:Initial()
                            " End of file : closetag.vim

SCRIPT  /Users/mochi/.local/share/nvim/plugged/indent-blankline.nvim/plugin/indent_blankline.vim
Sourced 1 time
Total time:   0.000964
 Self time:   0.000964

count  total (s)   self (s)
                            
    1              0.000016 if exists('g:loaded_indent_blankline') || !has('nvim-0.5.0')
                                finish
    1              0.000001 endif
    1              0.000004 let g:loaded_indent_blankline = 1
                            
    1              0.000005 function s:try(cmd)
                                try
                                    execute a:cmd
                                catch /E12/
                                    return
                                endtry
                            endfunction
                            
    1              0.000013 command! -bang IndentBlanklineRefresh call s:try('lua require("indent_blankline.commands").refresh("<bang>" == "!")')
    1              0.000024 command! -bang IndentBlanklineRefreshScroll call s:try('lua require("indent_blankline.commands").refresh("<bang>" == "!", true)')
    1              0.000004 command! -bang IndentBlanklineEnable call s:try('lua require("indent_blankline.commands").enable("<bang>" == "!")')
    1              0.000004 command! -bang IndentBlanklineDisable call s:try('lua require("indent_blankline.commands").disable("<bang>" == "!")')
    1              0.000004 command! -bang IndentBlanklineToggle call s:try('lua require("indent_blankline.commands").toggle("<bang>" == "!")')
                            
    1              0.000004 if exists(':IndentLinesEnable') && !g:indent_blankline_disable_warning_message
                                echohl Error
                                echom 'indent-blankline does not require IndentLine anymore, please remove it.'
                                echohl None
    1              0.000001 endif
                            
    1              0.000003 if !exists('g:__indent_blankline_setup_completed')
                                lua require("indent_blankline").setup {}
    1              0.000000 endif
                            
    1              0.000582 lua require("indent_blankline").init()
                            
    1              0.000007 augroup IndentBlanklineAutogroup
    1              0.000109     autocmd!
    1              0.000014     autocmd OptionSet list,shiftwidth,tabstop,expandtab IndentBlanklineRefresh
    1              0.000016     autocmd FileChangedShellPost,TextChanged,TextChangedI,CompleteChanged,BufWinEnter,Filetype * IndentBlanklineRefresh
    1              0.000003     autocmd WinScrolled * IndentBlanklineRefreshScroll
    1              0.000002     autocmd ColorScheme * lua require("indent_blankline.utils").reset_highlights()
    1              0.000002     autocmd VimEnter * lua require("indent_blankline").init()
    1              0.000001 augroup END
                            

SCRIPT  /Users/mochi/.local/share/nvim/plugged/vim-gitgutter/plugin/gitgutter.vim
Sourced 1 time
Total time:   0.006266
 Self time:   0.003030

count  total (s)   self (s)
    1              0.000005 scriptencoding utf-8
                            
    1              0.000014 if exists('g:loaded_gitgutter') || !has('signs') || &cp
                              finish
    1              0.000001 endif
    1              0.000003 let g:loaded_gitgutter = 1
                            
                            " Initialisation {{{
                            
    1              0.000004 if v:version < 703 || (v:version == 703 && !has("patch105"))
                              call gitgutter#utility#warn('Requires Vim 7.3.105')
                              finish
    1              0.000001 endif
                            
    1              0.000004 let s:nomodeline = (v:version > 703 || (v:version == 703 && has('patch442'))) ? '<nomodeline>' : ''
                            
    1              0.000004 function! s:obsolete(var)
                              if exists(a:var)
                                call gitgutter#utility#warn(a:var.' is obsolete and has no effect.')
                              endif
                            endfunction
                            
                            
    1              0.000004 let g:gitgutter_preview_win_location = get(g:, 'gitgutter_preview_win_location', 'bo')
    1              0.000003 if exists('*nvim_open_win')
    1              0.000003   let g:gitgutter_preview_win_floating = get(g:, 'gitgutter_preview_win_floating', 1)
    1              0.000011   let g:gitgutter_floating_window_options = get(g:, 'gitgutter_floating_window_options', {
                                    \ 'relative': 'cursor',
                                    \ 'row': 1,
                                    \ 'col': 0,
                                    \ 'width': 42,
                                    \ 'height': &previewheight,
                                    \ 'style': 'minimal'
                                    \ })
                            else
                              let default = exists('&previewpopup') ? !empty(&previewpopup) : 0
                              let g:gitgutter_preview_win_floating = get(g:, 'gitgutter_preview_win_floating', default)
                              let g:gitgutter_floating_window_options = get(g:, 'gitgutter_floating_window_options', {
                                    \ 'line': 'cursor+1',
                                    \ 'col': 'cursor',
                                    \ 'moved': 'any'
                                    \ })
    1              0.000001 endif
    1              0.000002 let g:gitgutter_enabled = get(g:, 'gitgutter_enabled', 1)
    1              0.000002 if exists('*sign_unplace')
    1              0.000003   let g:gitgutter_max_signs = get(g:, 'gitgutter_max_signs', -1)
                            else
                              let g:gitgutter_max_signs = get(g:, 'gitgutter_max_signs', 500)
    1              0.000000 endif
    1              0.000002 let g:gitgutter_signs             = get(g:, 'gitgutter_signs', 1)
    1              0.000003 let g:gitgutter_highlight_lines   = get(g:, 'gitgutter_highlight_lines', 0)
    1              0.000002 let g:gitgutter_highlight_linenrs = get(g:, 'gitgutter_highlight_linenrs', 0)
    1              0.000002 let g:gitgutter_sign_priority     = get(g:, 'gitgutter_sign_priority', 10)
                            " Nvim 0.4.0 has an expanding sign column
                            " The sign_place() function supports sign priority.
    1              0.000005 if (has('nvim-0.4.0') || exists('*sign_place')) && !exists('g:gitgutter_sign_allow_clobber')
    1              0.000002   let g:gitgutter_sign_allow_clobber = 1
    1              0.000000 endif
    1              0.000003 let g:gitgutter_sign_allow_clobber   = get(g:, 'gitgutter_sign_allow_clobber', 0)
    1              0.000003 let g:gitgutter_set_sign_backgrounds = get(g:, 'gitgutter_set_sign_backgrounds', 0)
    1              0.000002 let g:gitgutter_sign_added           = get(g:, 'gitgutter_sign_added', '+')
    1              0.000002 let g:gitgutter_sign_modified        = get(g:, 'gitgutter_sign_modified', '~')
    1              0.000002 let g:gitgutter_sign_removed         = get(g:, 'gitgutter_sign_removed', '_')
                            
    1   0.000882   0.000191 if gitgutter#utility#supports_overscore_sign()
    1              0.000007   let g:gitgutter_sign_removed_first_line = get(g:, 'gitgutter_sign_removed_first_line', '')
                            else
                              let g:gitgutter_sign_removed_first_line = get(g:, 'gitgutter_sign_removed_first_line', '_^')
    1              0.000001 endif
                            
    1              0.000004 let g:gitgutter_sign_removed_above_and_below = get(g:, 'gitgutter_sign_removed_above_and_below', '_')
    1              0.000003 let g:gitgutter_sign_modified_removed        = get(g:, 'gitgutter_sign_modified_removed', '~_')
    1              0.000002 let g:gitgutter_git_args                     = get(g:, 'gitgutter_git_args', '')
    1              0.000002 let g:gitgutter_diff_relative_to             = get(g:, 'gitgutter_diff_relative_to', 'index')
    1              0.000002 let g:gitgutter_diff_args                    = get(g:, 'gitgutter_diff_args', '')
    1              0.000002 let g:gitgutter_diff_base                    = get(g:, 'gitgutter_diff_base', '')
    1              0.000003 let g:gitgutter_map_keys                     = get(g:, 'gitgutter_map_keys', 1)
    1              0.000003 let g:gitgutter_terminal_reports_focus       = get(g:, 'gitgutter_terminal_reports_focus', 1)
    1              0.000002 let g:gitgutter_async                        = get(g:, 'gitgutter_async', 1)
    1              0.000002 let g:gitgutter_log                          = get(g:, 'gitgutter_log', 0)
    1              0.000003 let g:gitgutter_use_location_list            = get(g:, 'gitgutter_use_location_list', 0)
    1              0.000002 let g:gitgutter_close_preview_on_escape      = get(g:, 'gitgutter_close_preview_on_escape', 0)
    1              0.000003 let g:gitgutter_show_msg_on_hunk_jumping     = get(g:, 'gitgutter_show_msg_on_hunk_jumping', 1)
                            
    1              0.000003 let g:gitgutter_git_executable = get(g:, 'gitgutter_git_executable', 'git')
    1              0.000129 if !executable(g:gitgutter_git_executable)
                              if g:gitgutter_enabled
                                call gitgutter#utility#warn('Cannot find git. Please set g:gitgutter_git_executable.')
                              endif
                              finish
    1              0.000001 endif
                            
    1              0.000005 let default_grep = 'grep'
    1              0.000005 let g:gitgutter_grep = get(g:, 'gitgutter_grep', default_grep)
    1              0.000004 if !empty(g:gitgutter_grep)
    1              0.000180   if executable(split(g:gitgutter_grep)[0])
    1              0.000031     if $GREP_OPTIONS =~# '--color=always'
                                  let g:gitgutter_grep .= ' --color=never'
    1              0.000001     endif
                              else
                                if g:gitgutter_grep !=# default_grep
                                  call gitgutter#utility#warn('Cannot find '.g:gitgutter_grep.'. Please check g:gitgutter_grep.')
                                endif
                                let g:gitgutter_grep = ''
    1              0.000001   endif
    1              0.000000 endif
                            
    1   0.002744   0.000371 call gitgutter#highlight#define_highlights()
    1   0.000181   0.000020 call gitgutter#highlight#define_signs()
                            
                            " Prevent infinite loop where:
                            " - executing a job in the foreground launches a new window which takes the focus;
                            " - when the job finishes, focus returns to gvim;
                            " - the FocusGained event triggers a new job (see below).
    1   0.000018   0.000008 if gitgutter#utility#windows() && !(g:gitgutter_async && gitgutter#async#available())
                              set noshelltemp
    1              0.000001 endif
                            
                            " }}}
                            
                            " Primary functions {{{
                            
    1              0.000009 command! -bar GitGutterAll call gitgutter#all(1)
    1              0.000008 command! -bar GitGutter    call gitgutter#process_buffer(bufnr(''), 1)
                            
    1              0.000003 command! -bar GitGutterDisable call gitgutter#disable()
    1              0.000003 command! -bar GitGutterEnable  call gitgutter#enable()
    1              0.000002 command! -bar GitGutterToggle  call gitgutter#toggle()
                            
    1              0.000005 command! -bar GitGutterBufferDisable call gitgutter#buffer_disable()
    1              0.000002 command! -bar GitGutterBufferEnable  call gitgutter#buffer_enable()
    1              0.000002 command! -bar GitGutterBufferToggle  call gitgutter#buffer_toggle()
                            
    1              0.000002 command! -bar GitGutterQuickFix call gitgutter#quickfix(0)
    1              0.000002 command! -bar GitGutterQuickFixCurrentFile call gitgutter#quickfix(1)
                            
                            " }}}
                            
                            " Line highlights {{{
                            
    1              0.000004 command! -bar GitGutterLineHighlightsDisable call gitgutter#highlight#line_disable()
    1              0.000003 command! -bar GitGutterLineHighlightsEnable  call gitgutter#highlight#line_enable()
    1              0.000003 command! -bar GitGutterLineHighlightsToggle  call gitgutter#highlight#line_toggle()
                            
                            " }}}
                            
                            " 'number' column highlights {{{
    1              0.000004 command! -bar GitGutterLineNrHighlightsDisable call gitgutter#highlight#linenr_disable()
    1              0.000002 command! -bar GitGutterLineNrHighlightsEnable  call gitgutter#highlight#linenr_enable()
    1              0.000002 command! -bar GitGutterLineNrHighlightsToggle  call gitgutter#highlight#linenr_toggle()
                            " }}}
                            
                            " Signs {{{
                            
    1              0.000005 command! -bar GitGutterSignsEnable  call gitgutter#sign#enable()
    1              0.000004 command! -bar GitGutterSignsDisable call gitgutter#sign#disable()
    1              0.000004 command! -bar GitGutterSignsToggle  call gitgutter#sign#toggle()
                            
                            " }}}
                            
                            " Hunks {{{
                            
    1              0.000013 command! -bar -count=1 GitGutterNextHunk call gitgutter#hunk#next_hunk(<count>)
    1              0.000004 command! -bar -count=1 GitGutterPrevHunk call gitgutter#hunk#prev_hunk(<count>)
                            
    1              0.000005 command! -bar -range=% GitGutterStageHunk call gitgutter#hunk#stage(<line1>,<line2>)
    1              0.000002 command! -bar GitGutterUndoHunk    call gitgutter#hunk#undo()
    1              0.000002 command! -bar GitGutterPreviewHunk call gitgutter#hunk#preview()
                            
                            " Hunk text object
    1              0.000059 onoremap <silent> <Plug>(GitGutterTextObjectInnerPending) :<C-U>call gitgutter#hunk#text_object(1)<CR>
    1              0.000014 onoremap <silent> <Plug>(GitGutterTextObjectOuterPending) :<C-U>call gitgutter#hunk#text_object(0)<CR>
    1              0.000011 xnoremap <silent> <Plug>(GitGutterTextObjectInnerVisual)  :<C-U>call gitgutter#hunk#text_object(1)<CR>
    1              0.000007 xnoremap <silent> <Plug>(GitGutterTextObjectOuterVisual)  :<C-U>call gitgutter#hunk#text_object(0)<CR>
                            
                            
                            " Returns the git-diff hunks for the file or an empty list if there
                            " aren't any hunks.
                            "
                            " The return value is a list of lists.  There is one inner list per hunk.
                            "
                            "   [
                            "     [from_line, from_count, to_line, to_count],
                            "     [from_line, from_count, to_line, to_count],
                            "     ...
                            "   ]
                            "
                            " where:
                            "
                            " `from`  - refers to the staged file
                            " `to`    - refers to the working tree's file
                            " `line`  - refers to the line number where the change starts
                            " `count` - refers to the number of lines the change covers
    1              0.000008 function! GitGutterGetHunks()
                              let bufnr = bufnr('')
                              return gitgutter#utility#is_active(bufnr) ? gitgutter#hunk#hunks(bufnr) : []
                            endfunction
                            
                            " Returns an array that contains a summary of the hunk status for the current
                            " window.  The format is [ added, modified, removed ], where each value
                            " represents the number of lines added/modified/removed respectively.
    1              0.000007 function! GitGutterGetHunkSummary()
                              return gitgutter#hunk#summary(winbufnr(0))
                            endfunction
                            
                            " }}}
                            
                            " Folds {{{
                            
    1              0.000006 command! -bar GitGutterFold call gitgutter#fold#toggle()
                            
                            " }}}
                            
    1              0.000002 command! -bar GitGutterDebug call gitgutter#debug#debug()
                            
                            " Maps {{{
                            
    1              0.000022 nnoremap <silent> <expr> <Plug>(GitGutterNextHunk) &diff ? ']c' : ":\<C-U>execute v:count1 . 'GitGutterNextHunk'\<CR>"
    1              0.000013 nnoremap <silent> <expr> <Plug>GitGutterNextHunk   &diff ? ']c' : ":\<C-U>call gitgutter#utility#warn('Please change your map \<lt>Plug>GitGutterNextHunk to \<lt>Plug>(GitGutterNextHunk)')\<CR>"
    1              0.000009 nnoremap <silent> <expr> <Plug>(GitGutterPrevHunk) &diff ? '[c' : ":\<C-U>execute v:count1 . 'GitGutterPrevHunk'\<CR>"
    1              0.000011 nnoremap <silent> <expr> <Plug>GitGutterPrevHunk   &diff ? '[c' : ":\<C-U>call gitgutter#utility#warn('Please change your map \<lt>Plug>GitGutterPrevHunk to \<lt>Plug>(GitGutterPrevHunk)')\<CR>"
                            
    1              0.000006 xnoremap <silent> <Plug>(GitGutterStageHunk)   :GitGutterStageHunk<CR>
    1              0.000011 xnoremap <silent> <Plug>GitGutterStageHunk     :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterStageHunk to <lt>Plug>(GitGutterStageHunk)')<CR>
    1              0.000005 nnoremap <silent> <Plug>(GitGutterStageHunk)   :GitGutterStageHunk<CR>
    1              0.000010 nnoremap <silent> <Plug>GitGutterStageHunk     :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterStageHunk to <lt>Plug>(GitGutterStageHunk)')<CR>
    1              0.000005 nnoremap <silent> <Plug>(GitGutterUndoHunk)    :GitGutterUndoHunk<CR>
    1              0.000010 nnoremap <silent> <Plug>GitGutterUndoHunk      :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterUndoHunk to <lt>Plug>(GitGutterUndoHunk)')<CR>
    1              0.000005 nnoremap <silent> <Plug>(GitGutterPreviewHunk) :GitGutterPreviewHunk<CR>
    1              0.000010 nnoremap <silent> <Plug>GitGutterPreviewHunk   :call gitgutter#utility#warn('Please change your map <lt>Plug>GitGutterPreviewHunk to <lt>Plug>(GitGutterPreviewHunk)')<CR>
                            
                            " }}}
                            
    1              0.000008 function! s:on_bufenter()
                              call gitgutter#setup_maps()
                            
                              " To keep vim's start-up fast, do not process the buffer when vim is starting.
                              " Instead process it a short time later.  Normally we would rely on our
                              " CursorHold autocommand to handle this but it turns out CursorHold is not
                              " guaranteed to fire if the user has not typed anything yet; so set up a
                              " timer instead.  The disadvantage is that if CursorHold does fire, the
                              " plugin will do a round of unnecessary work; but since there will not have
                              " been any changes to the buffer since the first round, the second round
                              " will be cheap.
                              if has('vim_starting') && !$VIM_GITGUTTER_TEST
                                if exists('*timer_start')
                                  call timer_start(&updatetime, 'GitGutterCursorHold')
                                endif
                                return
                              endif
                            
                              if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
                              else
                                call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
                              endif
                            endfunction
                            
    1              0.000002 function! GitGutterCursorHold(timer)
                              execute 'doautocmd' s:nomodeline 'gitgutter CursorHold'
                            endfunction
                            
    1              0.000001 function! s:next_tick(cmd)
                              call timer_start(1, {-> execute(a:cmd)})
                            endfunction
                            
                            " Autocommands {{{
                            
    1              0.000006 augroup gitgutter
    1              0.000598   autocmd!
                            
    1              0.000033   autocmd TabEnter * let t:gitgutter_didtabenter = 1
                            
    1              0.000003   autocmd BufEnter * call s:on_bufenter()
                            
                              " Ensure Vim is always checking for CursorMoved to avoid CursorMoved
                              " being fired at the wrong time in floating preview window on Neovim.
                              " See vim/vim#2053.
    1              0.000003   autocmd CursorMoved * execute ''
                            
    1              0.000004   autocmd CursorHold,CursorHoldI * call gitgutter#process_buffer(bufnr(''), 0)
    1              0.000027   if exists('*timer_start') && has('lambda')
    1              0.000004     autocmd FileChangedShellPost * call s:next_tick("call gitgutter#process_buffer(+".expand('<abuf>').", 1)")
                              else
                                autocmd FileChangedShellPost * call gitgutter#process_buffer(+expand('<abuf>'), 1)
    1              0.000001   endif
                            
                              " Ensure that all buffers are processed when opening vim with multiple files, e.g.:
                              "
                              "   vim -o file1 file2
    1              0.000003   autocmd VimEnter * if winnr() != winnr('$') | call gitgutter#all(0) | endif
                            
    1              0.000003   autocmd ShellCmdPost * call gitgutter#all(1)
    1              0.000034   autocmd BufLeave term://* call gitgutter#all(1)
                            
    1              0.000008   autocmd User FugitiveChanged call gitgutter#all(1)
                            
    1              0.000003   autocmd BufFilePre  * GitGutterBufferDisable
    1              0.000002   autocmd BufFilePost * GitGutterBufferEnable
                            
                              " Handle all buffers when focus is gained, but only after it was lost.
                              " FocusGained gets triggered on startup with Neovim at least already.
                              " Therefore this tracks also if it was lost before.
    1              0.000012   let s:focus_was_lost = 0
    1              0.000004   autocmd FocusGained * if s:focus_was_lost | let s:focus_was_lost = 0 | call gitgutter#all(1) | endif
    1              0.000002   autocmd FocusLost * let s:focus_was_lost = 1
                            
    1              0.000004   if exists('##VimResume')
    1              0.000003     autocmd VimResume * call gitgutter#all(1)
    1              0.000001   endif
                            
    1              0.000002   autocmd ColorScheme * call gitgutter#highlight#define_highlights()
                            
                              " Disable during :vimgrep
    1              0.000005   autocmd QuickFixCmdPre  *vimgrep* let [g:gitgutter_was_enabled, g:gitgutter_enabled] = [g:gitgutter_enabled, 0]
    1              0.000003   autocmd QuickFixCmdPost *vimgrep* let g:gitgutter_enabled = g:gitgutter_was_enabled | unlet g:gitgutter_was_enabled
    1              0.000001 augroup END
                            
                            " }}}
                            
                            " vim:set et sw=2 fdm=marker:

SCRIPT  /Users/mochi/.local/share/nvim/plugged/vim-startify/plugin/startify.vim
Sourced 1 time
Total time:   0.000535
 Self time:   0.000535

count  total (s)   self (s)
                            " vim: et sw=2 sts=2
                            
                            " Plugin:      https://github.com/mhinz/vim-startify
                            " Description: A fancy start screen for Vim.
                            " Maintainer:  Marco Hinz <http://github.com/mhinz>
                            
    1              0.000034 if exists('g:loaded_startify') || &cp
                              finish
    1              0.000001 endif
    1              0.000006 let g:loaded_startify = 1
    1              0.000002 let g:startify_locked = 0
                            
    1              0.000014 if !get(g:, 'startify_disable_at_vimenter') && (!has('nvim') || has('nvim-0.3.5'))
                              " Only for Nvim v0.3.5+: https://github.com/neovim/neovim/issues/9885
    1              0.000009   set shortmess+=I
    1              0.000001 endif
                            
    1              0.000002 augroup startify
    1              0.000016   autocmd VimEnter    * nested call s:on_vimenter()
    1              0.000005   autocmd VimLeavePre * nested call s:on_vimleavepre()
    1              0.000005   autocmd QuickFixCmdPre  *vimgrep* let g:startify_locked = 1
    1              0.000004   autocmd QuickFixCmdPost *vimgrep* let g:startify_locked = 0
    1              0.000001 augroup END
                            
    1              0.000008 function! s:update_oldfiles(file)
                              if g:startify_locked || !exists('v:oldfiles')
                                return
                              endif
                              let idx = index(v:oldfiles, a:file)
                              if idx != -1
                                call remove(v:oldfiles, idx)
                              endif
                              call insert(v:oldfiles, a:file, 0)
                            endfunction
                            
    1              0.000001 function! s:on_vimenter()
                              if !argc() && line2byte('$') == -1
                                if get(g:, 'startify_session_autoload') && filereadable('Session.vim')
                                  source Session.vim
                                elseif !get(g:, 'startify_disable_at_vimenter')
                                  call startify#insane_in_the_membrane(1)
                                endif
                              endif
                              if get(g:, 'startify_update_oldfiles')
                                call map(v:oldfiles, 'fnamemodify(v:val, ":p")')
                                autocmd startify BufNewFile,BufRead,BufFilePre *
                                      \ call s:update_oldfiles(expand('<afile>:p'))
                              endif
                              autocmd! startify VimEnter
                            endfunction
                            
    1              0.000001 function! s:on_vimleavepre()
                              if get(g:, 'startify_session_persistence')
                                    \ && exists('v:this_session')
                                    \ && filewritable(v:this_session)
                                call startify#session_write(fnameescape(v:this_session))
                              endif
                            endfunction
                            
    1              0.000010 command! -nargs=? -bar -bang -complete=customlist,startify#session_list SLoad   call startify#session_load(<bang>0, <f-args>)
    1              0.000005 command! -nargs=? -bar -bang -complete=customlist,startify#session_list SSave   call startify#session_save(<bang>0, <f-args>)
    1              0.000004 command! -nargs=? -bar -bang -complete=customlist,startify#session_list SDelete call startify#session_delete(<bang>0, <f-args>)
    1              0.000003 command! -nargs=0 -bar SClose call startify#session_close()
    1              0.000003 command! -nargs=0 -bar Startify call startify#insane_in_the_membrane(0)
    1              0.000002 command! -nargs=0 -bar StartifyDebug call startify#debug()
                            
    1              0.000027 nnoremap <silent><plug>(startify-open-buffers) :<c-u>call startify#open_buffers()<cr>

SCRIPT  /Users/mochi/.local/share/nvim/plugged/which-key.nvim/plugin/which-key.vim
Sourced 1 time
Total time:   0.000135
 Self time:   0.000135

count  total (s)   self (s)
    1              0.000017 command! -nargs=* WhichKey lua require('which-key').show_command(<f-args>)

SCRIPT  /Users/mochi/.local/share/nvim/plugged/vim-devicons/plugin/webdevicons.vim
Sourced 1 time
Total time:   0.003930
 Self time:   0.001364

count  total (s)   self (s)
                            " Version: 0.11.0
                            " Webpage: https://github.com/ryanoasis/vim-devicons
                            " Maintainer: Ryan McIntyre <ryanoasis@gmail.com>
                            " License: see LICENSE
                            
    1              0.000007 let s:version = '0.11.0'
    1              0.000017 let s:plugin_home = expand('<sfile>:p:h:h')
                            
                            " set scriptencoding after 'encoding' and when using multibyte chars
    1              0.000003 scriptencoding utf-8
                            
                            " standard fix/safety: line continuation (avoiding side effects) {{{1
                            "========================================================================
    1              0.000008 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
                            " standard loading / not loading {{{1
                            "========================================================================
                            
    1              0.000004 if exists('g:loaded_webdevicons')
                              finish
    1              0.000001 endif
                            
    1              0.000002 let g:loaded_webdevicons = 1
                            
                            " config enable / disable settings {{{1
                            "========================================================================
                            
                            ""
                            " Set the variable to the default value, only if variable is not defined.
                            "
                            " @param {string} var Variable name with its scope.
                            " @param {*} default Default value for variable.
                            ""
    1              0.000005 function! s:set(var, default) abort
                              if !exists(a:var)
                                if type(a:default)
                                  execute 'let' a:var '=' string(a:default)
                                else
                                  execute 'let' a:var '=' a:default
                                endif
                              endif
                            endfunction
                            
    1   0.000026   0.000011 call s:set('g:webdevicons_enable', 1)
    1   0.000015   0.000004 call s:set('g:webdevicons_enable_nerdtree', 1)
    1   0.000032   0.000022 call s:set('g:webdevicons_enable_unite ', 1)
    1   0.000011   0.000003 call s:set('g:webdevicons_enable_denite', 1)
    1   0.000011   0.000003 call s:set('g:webdevicons_enable_vimfiler', 1)
    1   0.000010   0.000002 call s:set('g:webdevicons_enable_ctrlp', 1)
    1   0.000011   0.000003 call s:set('g:webdevicons_enable_airline_tabline', 1)
    1   0.000011   0.000003 call s:set('g:webdevicons_enable_airline_statusline', 1)
    1   0.000013   0.000003 call s:set('g:webdevicons_enable_airline_statusline_fileformat_symbols', 1)
    1   0.000012   0.000003 call s:set('g:webdevicons_enable_flagship_statusline', 1)
    1   0.000012   0.000003 call s:set('g:webdevicons_enable_flagship_statusline_fileformat_symbols', 1)
    1   0.000011   0.000002 call s:set('g:webdevicons_enable_startify', 1)
    1   0.000011   0.000003 call s:set('g:webdevicons_conceal_nerdtree_brackets', 1)
    1   0.000014   0.000006 call s:set('g:DevIconsAppendArtifactFix', has('gui_running') ? 1 : 0)
    1   0.000012   0.000003 call s:set('g:DevIconsArtifactFixChar', ' ')
                            
                            " config options {{{1
                            "========================================================================
                            
    1   0.000011   0.000003 call s:set('g:WebDevIconsUnicodeDecorateFileNodes', 1)
    1   0.000010   0.000003 call s:set('g:WebDevIconsUnicodeDecorateFolderNodes', 1)
    1   0.000010   0.000003 call s:set('g:DevIconsEnableFoldersOpenClose', 0)
    1   0.000010   0.000002 call s:set('g:DevIconsEnableFolderPatternMatching', 1)
    1   0.000011   0.000003 call s:set('g:DevIconsEnableFolderExtensionPatternMatching', 0)
    1   0.000010   0.000003 call s:set('g:DevIconsEnableDistro', 1)
    1   0.000011   0.000003 call s:set('g:WebDevIconsUnicodeDecorateFolderNodesExactMatches', 1)
    1   0.000011   0.000002 call s:set('g:WebDevIconsUnicodeGlyphDoubleWidth', 1)
    1   0.000012   0.000003 call s:set('g:WebDevIconsNerdTreeBeforeGlyphPadding', ' ')
    1   0.000011   0.000003 call s:set('g:WebDevIconsNerdTreeAfterGlyphPadding', ' ')
    1   0.000011   0.000003 call s:set('g:WebDevIconsNerdTreeGitPluginForceVAlign', 1)
    1   0.000011   0.000003 call s:set('g:NERDTreeUpdateOnCursorHold', 1) " Obsolete: For backward compatibility
    1   0.000011   0.000002 call s:set('g:NERDTreeGitStatusUpdateOnCursorHold', 1)
    1   0.000012   0.000003 call s:set('g:WebDevIconsTabAirLineBeforeGlyphPadding', ' ')
    1   0.000012   0.000003 call s:set('g:WebDevIconsTabAirLineAfterGlyphPadding', '')
                            
                            " config defaults {{{1
                            "========================================================================
                            
    1   0.000012   0.000003 call s:set('g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol', '')
    1   0.000012   0.000003 call s:set('g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol', '')
    1   0.000013   0.000004 call s:set('g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol', g:DevIconsEnableFoldersOpenClose ? '' : '')
    1   0.000012   0.000003 call s:set('g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol',  '')
    1   0.000011   0.000003 call s:set('g:DevIconsDefaultFolderOpenSymbol', '')
                            
                            " functions {{{1
                            "========================================================================
                            
                            " local functions {{{2
                            "========================================================================
                            
                            " scope: local
    1              0.000002 function s:getDistro()
                              if exists('s:distro')
                                return s:distro
                              endif
                            
                              if has('bsd')
                                let s:distro = ''
                                return s:distro
                              endif
                            
                              if g:DevIconsEnableDistro && executable('lsb_release')
                                let s:lsb = system('lsb_release -i')
                                if s:lsb =~# 'Arch'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Gentoo'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Ubuntu'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Cent'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Debian'
                                  let s:distro = ''
                                elseif s:lsb =~# 'Dock'
                                  let s:distro = ''
                                else
                                  let s:distro = ''
                                endif
                                return s:distro
                              endif
                            
                              let s:distro = ''
                              return s:distro
                            endfunction
                            
                            " scope: local
    1              0.000003 function s:isDarwin()
                              if exists('s:is_darwin')
                                return s:is_darwin
                              endif
                            
                              if exists('g:WebDevIconsOS')
                                let s:is_darwin = g:WebDevIconsOS ==? 'Darwin'
                                return s:is_darwin
                              endif
                            
                              if has('macunix')
                                let s:is_darwin = 1
                                return s:is_darwin
                              endif
                            
                              if ! has('unix')
                                let s:is_darwin = 0
                                return s:is_darwin
                              endif
                            
                              if system('uname -s') ==# "Darwin\n"
                                let s:is_darwin = 1
                              else
                                let s:is_darwin = 0
                              endif
                            
                              return s:is_darwin
                            endfunction
                            
                            " scope: local
    1              0.000001 function! s:strip(input)
                              return substitute(a:input, '^\s*\(.\{-}\)\s*$', '\1', '')
                            endfunction
                            
                            " scope: local
    1              0.000001 function! s:setDictionaries()
                            
                              let s:file_node_extensions = {
                                    \ 'styl'     : '',
                                    \ 'sass'     : '',
                                    \ 'scss'     : '',
                                    \ 'htm'      : '',
                                    \ 'html'     : '',
                                    \ 'slim'     : '',
                                    \ 'haml'     : '',
                                    \ 'ejs'      : '',
                                    \ 'css'      : '',
                                    \ 'less'     : '',
                                    \ 'md'       : '',
                                    \ 'mdx'      : '',
                                    \ 'markdown' : '',
                                    \ 'rmd'      : '',
                                    \ 'json'     : '',
                                    \ 'webmanifest' : '',
                                    \ 'js'       : '',
                                    \ 'mjs'      : '',
                                    \ 'jsx'      : '',
                                    \ 'rb'       : '',
                                    \ 'gemspec'  : '',
                                    \ 'rake'     : '',
                                    \ 'php'      : '',
                                    \ 'py'       : '',
                                    \ 'pyc'      : '',
                                    \ 'pyo'      : '',
                                    \ 'pyd'      : '',
                                    \ 'coffee'   : '',
                                    \ 'mustache' : '',
                                    \ 'hbs'      : '',
                                    \ 'conf'     : '',
                                    \ 'ini'      : '',
                                    \ 'yml'      : '',
                                    \ 'yaml'     : '',
                                    \ 'toml'     : '',
                                    \ 'bat'      : '',
                                    \ 'mk'       : '',
                                    \ 'jpg'      : '',
                                    \ 'jpeg'     : '',
                                    \ 'bmp'      : '',
                                    \ 'png'      : '',
                                    \ 'webp'     : '',
                                    \ 'gif'      : '',
                                    \ 'ico'      : '',
                                    \ 'twig'     : '',
                                    \ 'cpp'      : '',
                                    \ 'c++'      : '',
                                    \ 'cxx'      : '',
                                    \ 'cc'       : '',
                                    \ 'cp'       : '',
                                    \ 'c'        : '',
                                    \ 'cs'       : '',
                                    \ 'h'        : '',
                                    \ 'hh'       : '',
                                    \ 'hpp'      : '',
                                    \ 'hxx'      : '',
                                    \ 'hs'       : '',
                                    \ 'lhs'      : '',
                                    \ 'nix'      : '',
                                    \ 'lua'      : '',
                                    \ 'java'     : '',
                                    \ 'sh'       : '',
                                    \ 'fish'     : '',
                                    \ 'bash'     : '',
                                    \ 'zsh'      : '',
                                    \ 'ksh'      : '',
                                    \ 'csh'      : '',
                                    \ 'awk'      : '',
                                    \ 'ps1'      : '',
                                    \ 'ml'       : '',
                                    \ 'mli'      : '',
                                    \ 'diff'     : '',
                                    \ 'db'       : '',
                                    \ 'sql'      : '',
                                    \ 'dump'     : '',
                                    \ 'clj'      : '',
                                    \ 'cljc'     : '',
                                    \ 'cljs'     : '',
                                    \ 'edn'      : '',
                                    \ 'scala'    : '',
                                    \ 'go'       : '',
                                    \ 'dart'     : '',
                                    \ 'xul'      : '',
                                    \ 'sln'      : '',
                                    \ 'suo'      : '',
                                    \ 'pl'       : '',
                                    \ 'pm'       : '',
                                    \ 't'        : '',
                                    \ 'rss'      : '',
                                    \ 'f#'       : '',
                                    \ 'fsscript' : '',
                                    \ 'fsx'      : '',
                                    \ 'fs'       : '',
                                    \ 'fsi'      : '',
                                    \ 'rs'       : '',
                                    \ 'rlib'     : '',
                                    \ 'd'        : '',
                                    \ 'erl'      : '',
                                    \ 'hrl'      : '',
                                    \ 'ex'       : '',
                                    \ 'exs'      : '',
                                    \ 'eex'      : '',
                                    \ 'leex'     : '',
                                    \ 'heex'     : '',
                                    \ 'vim'      : '',
                                    \ 'ai'       : '',
                                    \ 'psd'      : '',
                                    \ 'psb'      : '',
                                    \ 'ts'       : '',
                                    \ 'tsx'      : '',
                                    \ 'jl'       : '',
                                    \ 'pp'       : '',
                                    \ 'vue'      : '',
                                    \ 'elm'      : '',
                                    \ 'swift'    : '',
                                    \ 'xcplayground' : '',
                                    \ 'tex'      : '',
                                    \ 'r'        : '',
                                    \ 'rproj'    : '',
                                    \ 'sol'      : '',
                                    \ 'pem'      : ''
                                    \}
                            
                              let s:file_node_exact_matches = {
                                    \ 'exact-match-case-sensitive-1.txt' : '1',
                                    \ 'exact-match-case-sensitive-2'     : '2',
                                    \ 'gruntfile.coffee'                 : '',
                                    \ 'gruntfile.js'                     : '',
                                    \ 'gruntfile.ls'                     : '',
                                    \ 'gulpfile.coffee'                  : '',
                                    \ 'gulpfile.js'                      : '',
                                    \ 'gulpfile.ls'                      : '',
                                    \ 'mix.lock'                         : '',
                                    \ 'dropbox'                          : '',
                                    \ '.ds_store'                        : '',
                                    \ '.gitconfig'                       : '',
                                    \ '.gitignore'                       : '',
                                    \ '.gitattributes'                   : '',
                                    \ '.gitlab-ci.yml'                   : '',
                                    \ '.bashrc'                          : '',
                                    \ '.zshrc'                           : '',
                                    \ '.zshenv'                          : '',
                                    \ '.zprofile'                        : '',
                                    \ '.vimrc'                           : '',
                                    \ '.gvimrc'                          : '',
                                    \ '_vimrc'                           : '',
                                    \ '_gvimrc'                          : '',
                                    \ '.bashprofile'                     : '',
                                    \ 'favicon.ico'                      : '',
                                    \ 'license'                          : '',
                                    \ 'node_modules'                     : '',
                                    \ 'react.jsx'                        : '',
                                    \ 'procfile'                         : '',
                                    \ 'dockerfile'                       : '',
                                    \ 'docker-compose.yml'               : '',
                                    \ 'rakefile'                         : '',
                                    \ 'config.ru'                        : '',
                                    \ 'gemfile'                          : '',
                                    \ 'makefile'                         : '',
                                    \ 'cmakelists.txt'                   : '',
                                    \ 'robots.txt'                       : ''
                                    \}
                            
                              let s:file_node_pattern_matches = {
                                    \ '.*jquery.*\.js$'       : '',
                                    \ '.*angular.*\.js$'      : '',
                                    \ '.*backbone.*\.js$'     : '',
                                    \ '.*require.*\.js$'      : '',
                                    \ '.*materialize.*\.js$'  : '',
                                    \ '.*materialize.*\.css$' : '',
                                    \ '.*mootools.*\.js$'     : '',
                                    \ '.*vimrc.*'             : '',
                                    \ 'Vagrantfile$'          : ''
                                    \}
                            
                              if !exists('g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols')
                                let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols = {}
                              endif
                            
                              if !exists('g:WebDevIconsUnicodeDecorateFileNodesExactSymbols')
                                " do not remove: exact-match-case-sensitive-*
                                let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols = {}
                              endif
                            
                              if !exists('g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols')
                                let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols = {}
                              endif
                            
                              " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
                              for [key, val] in items(s:file_node_extensions)
                                if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, key)
                                  let g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[key] = val
                                endif
                              endfor
                            
                              " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
                              for [key, val] in items(s:file_node_exact_matches)
                                if !has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, key)
                                  let g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[key] = val
                                endif
                              endfor
                            
                              " iterate to fix allow user overriding of specific individual keys in vimrc (only gvimrc was working previously)
                              for [key, val] in items(s:file_node_pattern_matches)
                                if !has_key(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols, key)
                                  let g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols[key] = val
                                endif
                              endfor
                            
                            endfunction
                            
                            " scope: local
    1              0.000002 function! s:setSyntax()
                              if g:webdevicons_enable_nerdtree == 1 && g:webdevicons_conceal_nerdtree_brackets == 1
                                augroup webdevicons_conceal_nerdtree_brackets
                                  au!
                                  autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\]" contained conceal containedin=NERDTreeFlags
                                  autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\[" contained conceal containedin=NERDTreeFlags
                                  autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\]" contained conceal containedin=NERDTreeLinkFile
                                  autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\]" contained conceal containedin=NERDTreeLinkDir
                                  autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\[" contained conceal containedin=NERDTreeLinkFile
                                  autocmd FileType nerdtree syntax match hideBracketsInNerdTree "\[" contained conceal containedin=NERDTreeLinkDir
                                  autocmd FileType nerdtree setlocal conceallevel=3
                                  autocmd FileType nerdtree setlocal concealcursor=nvic
                                augroup END
                              endif
                            endfunction
                            
                            " scope: local
                            " stole solution/idea from nerdtree-git-plugin :)
    1              0.000001 function! s:setCursorHold()
                              if g:webdevicons_enable_nerdtree
                                augroup webdevicons_cursor_hold
                                  autocmd CursorHold * silent! call s:CursorHoldUpdate()
                                augroup END
                              endif
                            endfunction
                            
                            " scope: local
                            " stole solution/idea from nerdtree-git-plugin :)
    1              0.000001 function! s:CursorHoldUpdate()
                              if g:NERDTreeUpdateOnCursorHold != 1 || g:NERDTreeGitStatusUpdateOnCursorHold != 1
                                return
                              endif
                            
                              if !exists('g:NERDTree') || !g:NERDTree.IsOpen()
                                return
                              endif
                            
                              " Do not update when a special buffer is selected
                              if !empty(&l:buftype)
                                return
                              endif
                            
                              " winnr need to make focus go to opened file
                              " CursorToTreeWin needed to avoid error on opening file
                              let l:winnr = winnr()
                              let l:altwinnr = winnr('#')
                            
                              call g:NERDTree.CursorToTreeWin()
                              call b:NERDTree.root.refreshFlags()
                              call NERDTreeRender()
                            
                              exec l:altwinnr . 'wincmd w'
                              exec l:winnr . 'wincmd w'
                            endfunction
                            
                            " scope: local
    1              0.000001 function! s:hardRefreshNerdTree()
                              if g:webdevicons_enable_nerdtree == 1 && g:webdevicons_conceal_nerdtree_brackets == 1 && g:NERDTree.IsOpen()
                                NERDTreeClose
                                NERDTree
                              endif
                            endfunction
                            
                            " scope: local
    1              0.000001 function! s:softRefreshNerdTree()
                              if g:webdevicons_enable_nerdtree == 1 && exists('g:NERDTree') && g:NERDTree.IsOpen()
                                NERDTreeToggle
                                NERDTreeToggle
                              endif
                            endfunction
                            
                            " local initialization {{{2
                            "========================================================================
                            
                            " scope: local
    1              0.000001 function! s:initialize()
                              call s:setDictionaries()
                              call s:setSyntax()
                              call s:setCursorHold()
                            
                              if exists('g:loaded_flagship') | call devicons#plugins#flagship#init() | endif
                              if exists('g:loaded_unite') && g:webdevicons_enable_unite | call devicons#plugins#unite#init() | endif
                              if exists('g:loaded_denite') && g:webdevicons_enable_denite | call devicons#plugins#denite#init() | endif
                              if exists('g:loaded_vimfiler') && g:webdevicons_enable_vimfiler | call devicons#plugins#vimfiler#init() | endif
                              if exists('g:loaded_ctrlp') && g:webdevicons_enable_ctrlp | call devicons#plugins#ctrlp#init() | endif
                              if exists('g:loaded_startify') && g:webdevicons_enable_startify | call devicons#plugins#startify#init() | endif
                            endfunction
                            
                            
                            " public functions {{{2
                            "========================================================================
                            
                            " scope: public
    1              0.000001 function! webdevicons#version()
                              return s:version
                            endfunction
                            
                            " scope: public
    1              0.000001 function! webdevicons#pluginHome()
                              return s:plugin_home
                            endfunction
                            
                            " scope: public
                            " allow the first version of refresh to now call softRefresh
    1              0.000001 function! webdevicons#refresh()
                              call webdevicons#softRefresh()
                            endfunction
                            
                            " scope: public
    1              0.000001 function! webdevicons#hardRefresh()
                              call s:setSyntax()
                              call s:hardRefreshNerdTree()
                            endfunction
                            
                            " scope: public
    1              0.000001 function! webdevicons#softRefresh()
                              call s:setSyntax()
                              call s:softRefreshNerdTree()
                            endfunction
                            
                            " a:1 (bufferName), a:2 (isDirectory)
                            " scope: public
    1              0.000020 function! WebDevIconsGetFileTypeSymbol(...) abort
                              if a:0 == 0
                                let fileNodeExtension = !empty(expand('%:e')) ? expand('%:e') : &filetype
                                let fileNode = expand('%:t')
                                let isDirectory = 0
                              else
                                let fileNodeExtension = fnamemodify(a:1, ':e')
                                let fileNode = fnamemodify(a:1, ':t')
                                if a:0 > 1
                                  let isDirectory = a:2
                                else
                                  let isDirectory = 0
                                endif
                              endif
                            
                              if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
                                let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
                                let fileNodeExtension = tolower(fileNodeExtension)
                                let fileNode = tolower(fileNode)
                            
                                for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
                                  if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
                                  endif
                                endfor
                            
                                if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
                                  if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
                                  elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
                                  elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                                  endif
                                endif
                            
                              else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                              endif
                            
                              let artifactFix = s:DevIconsGetArtifactFix()
                            
                              return symbol . artifactFix
                            
                            endfunction
                            
                            " scope: local
                            " Temporary (hopefully) fix for glyph issues in gvim (proper fix is with the
                            " actual font patcher)
    1              0.000004 function! s:DevIconsGetArtifactFix()
                              if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
                              else
                                let artifactFix = ''
                              endif
                            
                              return artifactFix
                            endfunction
                            
                            " scope: public
    1              0.000001 function! WebDevIconsGetFileFormatSymbol(...)
                              let fileformat = ''
                              let bomb = ''
                            
                              if (&bomb && g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol !=? '')
                                let bomb = g:WebDevIconsUnicodeByteOrderMarkerDefaultSymbol . ' '
                              endif
                            
                              if &fileformat ==? 'dos'
                                let fileformat = ''
                              elseif &fileformat ==? 'unix'
                                let fileformat = s:isDarwin() ? '' : s:getDistro()
                              elseif &fileformat ==? 'mac'
                                let fileformat = ''
                              endif
                            
                              let artifactFix = s:DevIconsGetArtifactFix()
                            
                              return bomb . fileformat . artifactFix
                            endfunction
                            
                            " for airline plugin {{{3
                            "========================================================================
                            
                            " scope: public
    1              0.000001 function! AirlineWebDevIcons(...)
                              let w:airline_section_x = get(w:, 'airline_section_x',
                                    \ get(g:, 'airline_section_x', ''))
                              let w:airline_section_x .= ' %{WebDevIconsGetFileTypeSymbol()} '
                              let hasFileFormatEncodingPart = airline#parts#ffenc() !=? ''
                              if g:webdevicons_enable_airline_statusline_fileformat_symbols && hasFileFormatEncodingPart
                                let w:airline_section_y = ' %{&fenc . " " . WebDevIconsGetFileFormatSymbol()} '
                              endif
                            endfunction
                            
    1              0.000011 if g:webdevicons_enable == 1 && exists('g:loaded_airline') && g:loaded_airline == 1 && g:webdevicons_enable_airline_statusline
                              call airline#add_statusline_func('AirlineWebDevIcons')
    1              0.000002 endif
                            
    1              0.000003 if g:webdevicons_enable == 1 && g:webdevicons_enable_airline_tabline
                              " Store original formatter.
    1              0.000012   let g:_webdevicons_airline_orig_formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    1              0.000011   let g:airline#extensions#tabline#formatter = 'webdevicons'
    1              0.000001 endif
                            
                            " for nerdtree plugin {{{3
                            "========================================================================
                            
                            " scope: public
    1              0.000002 function! NERDTreeWebDevIconsRefreshListener(event)
                              let path = a:event.subject
                              let postPadding = g:WebDevIconsNerdTreeAfterGlyphPadding
                              let prePadding = g:WebDevIconsNerdTreeBeforeGlyphPadding
                              let hasGitFlags = (len(path.flagSet._flagsForScope('git')) > 0)
                              let hasGitNerdTreePlugin = (exists('g:loaded_nerdtree_git_status') == 1)
                              let artifactFix = s:DevIconsGetArtifactFix()
                            
                              " align vertically at the same level: non git-flag nodes with git-flag nodes
                              if g:WebDevIconsNerdTreeGitPluginForceVAlign && !hasGitFlags && hasGitNerdTreePlugin
                                let prePadding .= ' '
                              endif
                            
                              if !path.isDirectory
                                " Hey we got a regular file, lets get it's proper icon
                                let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str()) . postPadding
                            
                              elseif path.isDirectory && g:WebDevIconsUnicodeDecorateFolderNodes == 1
                                " Ok we got a directory, some more tests and checks
                                let directoryOpened = 0
                            
                                if g:DevIconsEnableFoldersOpenClose && len(path.flagSet._flagsForScope('webdevicons')) > 0
                                  " did the user set different icons for open and close?
                            
                                  " isOpen is not available on the path listener directly
                                  " but we added one via overriding particular keymappings for NERDTree
                                  if has_key(path, 'isOpen') && path.isOpen == 1
                                    let directoryOpened = 1
                                  endif
                                endif
                            
                                if g:WebDevIconsUnicodeDecorateFolderNodesExactMatches == 1
                                  " Did the user enable exact matching of folder type/names
                                  " think node_modules
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . WebDevIconsGetFileTypeSymbol(path.str(), path.isDirectory) . postPadding
                                    endif
                                  endif
                            
                                else
                                  " the user did not enable exact matching
                                  if g:DevIconsEnableFoldersOpenClose && directoryOpened
                                    " the folder is open
                                    let flag = prePadding . g:DevIconsDefaultFolderOpenSymbol . artifactFix . postPadding
                                  else
                                    " the folder is not open
                                    if path.isSymLink
                                      " We have a symlink
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesSymlinkSymbol . artifactFix . postPadding
                                    else
                                      " We have a regular folder
                                      let flag = prePadding . g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol . artifactFix . postPadding
                                    endif
                                  endif
                            
                                endif
                            
                              else
                                let flag = prePadding . ' ' . artifactFix . postPadding
                              endif
                            
                              call path.flagSet.clearFlags('webdevicons')
                            
                              if flag !=? ''
                                call path.flagSet.addFlag('webdevicons', flag)
                              endif
                            
                            endfunction
                            
                            " call setup after processing all the functions (to avoid errors) {{{1
                            "========================================================================
                            " had some issues with VimEnter, for now using:
    1   0.002267   0.000010 call s:initialize()
                            
                            " standard fix/safety: line continuation (avoiding side effects) {{{1
                            "========================================================================
    1              0.000026 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " modeline syntax:
                            " vim: fdm=marker tabstop=2 softtabstop=2 shiftwidth=2 expandtab:

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/gzip.vim
Sourced 1 time
Total time:   0.000426
 Self time:   0.000426

count  total (s)   self (s)
                            " Vim plugin for editing compressed files.
                            " Maintainer: Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2016 Oct 30
                            
                            " Exit quickly when:
                            " - this plugin was already loaded
                            " - when 'compatible' is set
                            " - some autocommands are already taking care of compressed files
    1              0.000017 if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
                              finish
    1              0.000001 endif
    1              0.000009 let loaded_gzip = 1
                            
    1              0.000002 augroup gzip
                              " Remove all gzip autocommands
    1              0.000046   au!
                            
                              " Enable editing of gzipped files.
                              " The functions are defined in autoload/gzip.vim.
                              "
                              " Set binary mode before reading the file.
                              " Use "gzip -d", gunzip isn't always available.
    1              0.000036   autocmd BufReadPre,FileReadPre	*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
    1              0.000005   autocmd BufReadPost,FileReadPost	*.gz  call gzip#read("gzip -dn")
    1              0.000006   autocmd BufReadPost,FileReadPost	*.bz2 call gzip#read("bzip2 -d")
    1              0.000003   autocmd BufReadPost,FileReadPost	*.Z   call gzip#read("uncompress")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.lzma call gzip#read("lzma -d")
    1              0.000003   autocmd BufReadPost,FileReadPost	*.xz  call gzip#read("xz -d")
    1              0.000003   autocmd BufReadPost,FileReadPost	*.lz  call gzip#read("lzip -d")
    1              0.000006   autocmd BufReadPost,FileReadPost	*.zst call gzip#read("zstd -d --rm")
    1              0.000003   autocmd BufReadPost,FileReadPost	*.br call gzip#read("brotli -d --rm")
    1              0.000004   autocmd BufReadPost,FileReadPost	*.lzo call gzip#read("lzop -d -U")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.gz  call gzip#write("gzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.bz2 call gzip#write("bzip2")
    1              0.000005   autocmd BufWritePost,FileWritePost	*.Z   call gzip#write("compress -f")
    1              0.000006   autocmd BufWritePost,FileWritePost	*.lzma call gzip#write("lzma -z")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.xz  call gzip#write("xz -z")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.lz  call gzip#write("lzip")
    1              0.000004   autocmd BufWritePost,FileWritePost	*.zst  call gzip#write("zstd --rm")
    1              0.000003   autocmd BufWritePost,FileWritePost	*.br  call gzip#write("brotli --rm")
    1              0.000005   autocmd BufWritePost,FileWritePost	*.lzo  call gzip#write("lzop -U")
    1              0.000003   autocmd FileAppendPre			*.gz  call gzip#appre("gzip -dn")
    1              0.000002   autocmd FileAppendPre			*.bz2 call gzip#appre("bzip2 -d")
    1              0.000002   autocmd FileAppendPre			*.Z   call gzip#appre("uncompress")
    1              0.000003   autocmd FileAppendPre			*.lzma call gzip#appre("lzma -d")
    1              0.000005   autocmd FileAppendPre			*.xz   call gzip#appre("xz -d")
    1              0.000002   autocmd FileAppendPre			*.lz   call gzip#appre("lzip -d")
    1              0.000002   autocmd FileAppendPre			*.zst call gzip#appre("zstd -d --rm")
    1              0.000003   autocmd FileAppendPre			*.br call gzip#appre("brotli -d --rm")
    1              0.000004   autocmd FileAppendPre			*.lzo call gzip#appre("lzop -d -U")
    1              0.000003   autocmd FileAppendPost		*.gz  call gzip#write("gzip")
    1              0.000002   autocmd FileAppendPost		*.bz2 call gzip#write("bzip2")
    1              0.000002   autocmd FileAppendPost		*.Z   call gzip#write("compress -f")
    1              0.000002   autocmd FileAppendPost		*.lzma call gzip#write("lzma -z")
    1              0.000002   autocmd FileAppendPost		*.xz call gzip#write("xz -z")
    1              0.000002   autocmd FileAppendPost		*.lz call gzip#write("lzip")
    1              0.000002   autocmd FileAppendPost		*.zst call gzip#write("zstd --rm")
    1              0.000002   autocmd FileAppendPost		*.br call gzip#write("brotli --rm")
    1              0.000002   autocmd FileAppendPost		*.lzo call gzip#write("lzop -U")
    1              0.000005 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/health.vim
Sourced 1 time
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
    1              0.000012 autocmd CmdUndefined CheckHealth checkhealth

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/man.vim
Sourced 1 time
Total time:   0.000247
 Self time:   0.000247

count  total (s)   self (s)
                            " Maintainer: Anmol Sethi <hi@nhooyr.io>
                            
    1              0.000006 if exists('g:loaded_man')
                              finish
    1              0.000001 endif
    1              0.000007 let g:loaded_man = 1
                            
    1              0.000031 command! -bang -bar -addr=other -complete=customlist,man#complete -nargs=* Man
                                  \ if <bang>0 | call man#init_pager() |
                                  \ else | call man#open_page(<count>, <q-mods>, <f-args>) | endif
                            
    1              0.000002 augroup man
    1              0.000064   autocmd!
    1              0.000007   autocmd BufReadCmd man://* call man#read_page(matchstr(expand('<amatch>'), 'man://\zs.*'))
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/matchit.vim
Sourced 1 time
Total time:   0.002826
 Self time:   0.002130

count  total (s)   self (s)
                            " Nvim: load the matchit plugin by default.
    1              0.000012 if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
    1   0.002731   0.002035   packadd matchit
    1              0.000004 endif

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
Sourced 1 time
Total time:   0.000674
 Self time:   0.000674

count  total (s)   self (s)
                            "  matchit.vim: (global plugin) Extended "%" matching
                            "  Maintainer:  Christian Brabandt
                            "  Version:     1.17
                            "  Last Change: 2019 Oct 24
                            "  Repository:  https://github.com/chrisbra/matchit
                            "  Previous URL:http://www.vim.org/script.php?script_id=39
                            "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
                            
                            " Documentation:
                            "  The documentation is in a separate file: ../doc/matchit.txt
                            
                            " Credits:
                            "  Vim editor by Bram Moolenaar (Thanks, Bram!)
                            "  Original script and design by Raul Segura Acevedo
                            "  Support for comments by Douglas Potts
                            "  Support for back references and other improvements by Benji Fisher
                            "  Support for many languages by Johannes Zellner
                            "  Suggestions for improvement, bug reports, and support for additional
                            "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
                            "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
                            
                            " Debugging:
                            "  If you'd like to try the built-in debugging commands...
                            "   :MatchDebug      to activate debugging for the current buffer
                            "  This saves the values of several key script variables as buffer-local
                            "  variables.  See the MatchDebug() function, below, for details.
                            
                            " TODO:  I should think about multi-line patterns for b:match_words.
                            "   This would require an option:  how many lines to scan (default 1).
                            "   This would be useful for Python, maybe also for *ML.
                            " TODO:  Maybe I should add a menu so that people will actually use some of
                            "   the features that I have implemented.
                            " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
                            "   Match_wrapper() instead.
                            " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
                            " TODO:  Make backrefs safer by using '\V' (very no-magic).
                            " TODO:  Add a level of indirection, so that custom % scripts can use my
                            "   work but extend it.
                            
                            " Allow user to prevent loading and prevent duplicate loading.
    1              0.000015 if exists("g:loaded_matchit") || &cp
                              finish
    1              0.000001 endif
    1              0.000009 let g:loaded_matchit = 1
                            
    1              0.000004 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000018 nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
    1              0.000007 nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
    1              0.000012 xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>m'gv``
    1              0.000007 xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
    1              0.000007 onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
    1              0.000006 onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
                            
    1              0.000005 nmap <silent> %  <Plug>(MatchitNormalForward)
    1              0.000004 nmap <silent> g% <Plug>(MatchitNormalBackward)
    1              0.000004 xmap <silent> %  <Plug>(MatchitVisualForward)
    1              0.000004 xmap <silent> g% <Plug>(MatchitVisualBackward)
    1              0.000004 omap <silent> %  <Plug>(MatchitOperationForward)
    1              0.000004 omap <silent> g% <Plug>(MatchitOperationBackward)
                            
                            " Analogues of [{ and ]} using matching patterns:
    1              0.000007 nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
    1              0.000006 nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
    1              0.000007 xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
    1              0.000006 xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
    1              0.000007 onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
    1              0.000006 onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
                            
    1              0.000005 nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
    1              0.000004 nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
    1              0.000004 xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
    1              0.000004 xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
    1              0.000004 omap <silent> [% <Plug>(MatchitOperationMultiBackward)
    1              0.000004 omap <silent> ]% <Plug>(MatchitOperationMultiForward)
                            
                            " text object:
    1              0.000012 xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
    1              0.000004 xmap a% <Plug>(MatchitVisualTextObject)
                            
                            " Call this function to turn on debugging information.  Every time the main
                            " script is run, buffer variables will be saved.  These can be used directly
                            " or viewed using the menu items below.
    1              0.000005 if !exists(":MatchDebug")
    1              0.000004   command! -nargs=0 MatchDebug call matchit#Match_debug()
    1              0.000001 endif
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim:sts=2:sw=2:et:

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/matchparen.vim
Sourced 1 time
Total time:   0.000709
 Self time:   0.000709

count  total (s)   self (s)
                            " Vim plugin for showing matching parens
                            " Maintainer:  Bram Moolenaar <Bram@vim.org>
                            " Last Change: 2021 Apr 08
                            
                            " Exit quickly when:
                            " - this plugin was already loaded (or disabled)
                            " - when 'compatible' is set
                            " - the "CursorMoved" autocmd event is not available.
    1              0.000011 if exists("g:loaded_matchparen") || &cp || !exists("##CursorMoved")
                              finish
    1              0.000001 endif
    1              0.000008 let g:loaded_matchparen = 1
                            
    1              0.000003 if !exists("g:matchparen_timeout")
    1              0.000005   let g:matchparen_timeout = 300
    1              0.000001 endif
    1              0.000002 if !exists("g:matchparen_insert_timeout")
    1              0.000005   let g:matchparen_insert_timeout = 60
    1              0.000001 endif
                            
    1              0.000002 augroup matchparen
                              " Replace all matchparen autocommands
    1              0.000010   autocmd! CursorMoved,CursorMovedI,WinEnter * call s:Highlight_Matching_Pair()
    1              0.000003   autocmd! WinLeave * call s:Remove_Matches()
    1              0.000003   if exists('##TextChanged')
    1              0.000005     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
    1              0.000001   endif
    1              0.000001 augroup END
                            
                            " Skip the rest if it was already done.
    1              0.000006 if exists("*s:Highlight_Matching_Pair")
                              finish
    1              0.000001 endif
                            
    1              0.000004 let s:cpo_save = &cpo
    1              0.000005 set cpo-=C
                            
                            " The function that is invoked (very often) to define a ":match" highlighting
                            " for any matching paren.
    1              0.000003 func s:Highlight_Matching_Pair()
                              " Remove any previous match.
                              call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
                              if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
                              let c_lnum = line('.')
                              let c_col = col('.')
                              let before = 0
                            
                              let text = getline(c_lnum)
                              let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
                              if empty(matches)
                                let [c_before, c] = ['', '']
                              else
                                let [c_before, c] = matches[1:2]
                              endif
                              let plist = split(&matchpairs, '.\zs[:,]')
                              let i = index(plist, c)
                              if i < 0
                                " not found, in Insert mode try character before the cursor
                                if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
                                endif
                                if i < 0
                                  " not found, nothing to do
                                  return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' .
                            	\ '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) .
                            	    \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif
                            endfunction
                            
    1              0.000006 func s:Remove_Matches()
                              if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            endfunc
                            
                            
                            " Define commands that will disable and enable the plugin.
    1              0.000004 command DoMatchParen call s:DoMatchParen()
    1              0.000003 command NoMatchParen call s:NoMatchParen()
                            
    1              0.000002 func s:NoMatchParen()
                              let w = winnr()
                              noau windo silent! call matchdelete(3)
                              unlet! g:loaded_matchparen
                              exe "noau ". w . "wincmd w"
                              au! matchparen
                            endfunc
                            
    1              0.000001 func s:DoMatchParen()
                              runtime plugin/matchparen.vim
                              let w = winnr()
                              silent windo doau CursorMoved
                              exe "noau ". w . "wincmd w"
                            endfunc
                            
    1              0.000009 let &cpo = s:cpo_save
    1              0.000006 unlet s:cpo_save

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/netrwPlugin.vim
Sourced 1 time
Total time:   0.001148
 Self time:   0.001148

count  total (s)   self (s)
                            " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
                            "            PLUGIN SECTION
                            " Date:		Feb 09, 2021
                            " Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
                            " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
                            " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
                            "               *as is* and comes with no warranty of any kind, either
                            "               expressed or implied. By using this plugin, you agree that
                            "               in no event will the copyright holder be liable for any damages
                            "               resulting from the use of this software.
                            "
                            "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
                            "  (James 1:22 RSV)
                            " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
                            " Load Once: {{{1
    1              0.000009 if &cp || exists("g:loaded_netrwPlugin")
                             finish
    1              0.000001 endif
    1              0.000009 let g:loaded_netrwPlugin = "v171"
    1              0.000003 let s:keepcpo = &cpo
    1              0.000005 set cpo&vim
                            "DechoRemOn
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
                            
                            " Local Browsing Autocmds: {{{2
    1              0.000002 augroup FileExplorer
    1              0.000242  au!
    1              0.000007  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
    1              0.000003  au BufEnter *	sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000003  au VimEnter *	sil call s:VimEnter(expand("<amatch>"))
    1              0.000011  if has("win32") || has("win95") || has("win64") || has("win16")
                              au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
    1              0.000001  endif
    1              0.000001 augroup END
                            
                            " Network Browsing Reading Writing: {{{2
    1              0.000001 augroup Network
    1              0.000029  au!
    1              0.000006  au BufReadCmd   file://*											call netrw#FileUrlEdit(expand("<amatch>"))
    1              0.000017  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
    1              0.000018  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
    1              0.000018  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
    1              0.000015  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*			exe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
    1              0.000001  try
    1              0.000013   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
                             catch /^Vim\%((\a\+)\)\=:E216/
                              au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*	exe 'Nsource '.fnameescape(expand("<amatch>"))
    1              0.000001  endtry
    1              0.000001 augroup END
                            
                            " Commands: :Nread, :Nwrite, :NetUserPass {{{2
    1              0.000009 com! -count=1 -nargs=*	Nread		let s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
    1              0.000009 com! -range=% -nargs=*	Nwrite		let s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000003 com! -nargs=*		NetUserPass	call NetUserPass(<f-args>)
    1              0.000005 com! -nargs=*	        Nsource		let s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
    1              0.000003 com! -nargs=?		Ntree		call netrw#SetTreetop(1,<q-args>)
                            
                            " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
    1              0.000240 com! -nargs=* -bar -bang -count=0 -complete=dir	Explore		call netrw#Explore(<count>,0,0+<bang>0,<q-args>)
    1              0.000005 com! -nargs=* -bar -bang -count=0 -complete=dir	Sexplore	call netrw#Explore(<count>,1,0+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir	Hexplore	call netrw#Explore(<count>,1,2+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir	Vexplore	call netrw#Explore(<count>,1,4+<bang>0,<q-args>)
    1              0.000004 com! -nargs=* -bar       -count=0 -complete=dir	Texplore	call netrw#Explore(<count>,0,6        ,<q-args>)
    1              0.000003 com! -nargs=* -bar -bang			Nexplore	call netrw#Explore(-1,0,0,<q-args>)
    1              0.000002 com! -nargs=* -bar -bang			Pexplore	call netrw#Explore(-2,0,0,<q-args>)
    1              0.000004 com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore	call netrw#Lexplore(<count>,<bang>0,<q-args>)
                            
                            " Commands: NetrwSettings {{{2
    1              0.000003 com! -nargs=0	NetrwSettings	call netrwSettings#NetrwSettings()
    1              0.000003 com! -bang	NetrwClean	call netrw#Clean(<bang>0)
                            
                            " Maps:
    1              0.000004 if !exists("g:netrw_nogx")
    1              0.000008  if maparg('gx','n') == ""
    1              0.000019   if !hasmapto('<Plug>NetrwBrowseX')
    1              0.000007    nmap <unique> gx <Plug>NetrwBrowseX
    1              0.000001   endif
    1              0.000009   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
    1              0.000001  endif
    1              0.000005  if maparg('gx','x') == ""
    1              0.000009   if !hasmapto('<Plug>NetrwBrowseXVis')
    1              0.000005    xmap <unique> gx <Plug>NetrwBrowseXVis
    1              0.000001   endif
    1              0.000006   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
    1              0.000001  endif
    1              0.000001 endif
    1              0.000003 if exists("g:netrw_usetab") && g:netrw_usetab
                             if maparg('<c-tab>','n') == ""
                              nmap <unique> <c-tab> <Plug>NetrwShrink
                             endif
                             nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
    1              0.000003 fun! s:LocalBrowse(dirname)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
                              if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
                              if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
                              endif
                            
                            "  call Dret("s:LocalBrowse")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
                            "             Its purpose: to look over all windows and run s:LocalBrowse() on
                            "             them, which checks if they're directories and will create a directory
                            "             listing when appropriate.
                            "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
                            "             has already been called.
    1              0.000002 fun! s:VimEnter(dirname)
                            "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
                              if has('nvim') || v:version < 802
                              " Johann Hchtl: reported that the call range... line causes an E488: Trailing characters
                              "                error with neovim. I suspect its because neovim hasn't updated with recent
                              "                vim patches. As is, this code will have problems with popup terminals
                              "                instantiated before the VimEnter event runs.
                              " Ingo Karkat  : E488 also in Vim 8.1.1602
                              let curwin       = winnr()
                              let s:vimentered = 1
                              windo call s:LocalBrowse(expand("%:p"))
                              exe curwin."wincmd w"
                             else
                              " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
                              " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
                              let s:vimentered = 1
                              call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
                             endif
                            "  call Dret("s:VimEnter")
                            endfun
                            
                            " ---------------------------------------------------------------------
                            " NetrwStatusLine: {{{1
    1              0.000001 fun! NetrwStatusLine()
                            "  let g:stlmsg= "Xbufnr=".w:netrw_explore_bufnr." bufnr=".bufnr("%")." Xline#".w:netrw_explore_line." line#".line(".")
                              if !exists("w:netrw_explore_bufnr") || w:netrw_explore_bufnr != bufnr("%") || !exists("w:netrw_explore_line") || w:netrw_explore_line != line(".") || !exists("w:netrw_explore_list")
                               let &stl= s:netrw_explore_stl
                               if exists("w:netrw_explore_bufnr")|unlet w:netrw_explore_bufnr|endif
                               if exists("w:netrw_explore_line")|unlet w:netrw_explore_line|endif
                               return ""
                              else
                               return "Match ".w:netrw_explore_mtchcnt." of ".w:netrw_explore_listlen
                              endif
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " NetUserPass: set username and password for subsequent ftp transfer {{{1
                            "   Usage:  :call NetUserPass()			-- will prompt for userid and password
                            "	    :call NetUserPass("uid")		-- will prompt for password
                            "	    :call NetUserPass("uid","password") -- sets global userid and password
    1              0.000001 fun! NetUserPass(...)
                            
                             " get/set userid
                             if a:0 == 0
                            "  call Dfunc("NetUserPass(a:0<".a:0.">)")
                              if !exists("g:netrw_uid") || g:netrw_uid == ""
                               " via prompt
                               let g:netrw_uid= input('Enter username: ')
                              endif
                             else	" from command line
                            "  call Dfunc("NetUserPass(a:1<".a:1.">) {")
                              let g:netrw_uid= a:1
                             endif
                            
                             " get password
                             if a:0 <= 1 " via prompt
                            "  call Decho("a:0=".a:0." case <=1:")
                              let g:netrw_passwd= inputsecret("Enter Password: ")
                             else " from command line
                            "  call Decho("a:0=".a:0." case >1: a:2<".a:2.">")
                              let g:netrw_passwd=a:2
                             endif
                            "  call Dret("NetUserPass")
                            endfun
                            
                            " ------------------------------------------------------------------------
                            " Modelines And Restoration: {{{1
    1              0.000006 let &cpo= s:keepcpo
    1              0.000002 unlet s:keepcpo
                            " vim:ts=8 fdm=marker

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/rplugin.vim
Sourced 1 time
Total time:   0.000792
 Self time:   0.000184

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_remote_plugins')
                              finish
    1              0.000001 endif
    1              0.000011 let g:loaded_remote_plugins = '/path/to/manifest'
                            
                            " Get the path to the rplugin manifest file.
    1              0.000002 function! s:GetManifestPath() abort
                              let manifest_base = ''
                            
                              if exists('$NVIM_RPLUGIN_MANIFEST')
                                return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
                              endif
                            
                              let dest = stdpath('data')
                              if !empty(dest)
                                if !isdirectory(dest)
                                  call mkdir(dest, 'p', 0700)
                                endif
                                let manifest_base = dest
                              endif
                            
                              return manifest_base.'/rplugin.vim'
                            endfunction
                            
                            " Old manifest file based on known script locations.
    1              0.000001 function! s:GetOldManifestPaths() abort
                              let prefix = exists('$MYVIMRC')
                                    \ ? $MYVIMRC
                                    \ : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
                              let origpath = fnamemodify(expand(prefix, 1), ':h')
                                    \.'/.'.fnamemodify(prefix, ':t').'-rplugin~'
                              if !has('win32')
                                return [origpath]
                              endif
                              " Windows used to use $APPLOCALDATA/nvim but stdpath('data') is
                              " $XDG_DATA_DIR/nvim-data
                              let pseudostdpath = exists('$LOCALAPPDATA') ? '$LOCALAPPDATA' : '~/AppData/Local'
                              let pseudostdpath = fnamemodify(expand(pseudostdpath), ':p')
                              return [substitute(pseudostdpath, '[/\\]\=$', '/', '') . 'nvim/rplugin.vim', origpath]
                            endfunction
                            
    1              0.000001 function! s:GetManifest() abort
                              let manifest = s:GetManifestPath()
                              if !filereadable(manifest)
                                " Check if an old manifest file exists and move it to the new location.
                                for old_manifest in s:GetOldManifestPaths()
                                  if filereadable(old_manifest)
                                    call rename(old_manifest, manifest)
                                    break
                                  endif
                                endfor
                              endif
                              return manifest
                            endfunction
                            
    1              0.000001 function! s:LoadRemotePlugins() abort
                              let g:loaded_remote_plugins = s:GetManifest()
                              if filereadable(g:loaded_remote_plugins)
                                execute 'source' fnameescape(g:loaded_remote_plugins)
                              endif
                            endfunction
                            
    1              0.000004 command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
                            
    1   0.000615   0.000008 call s:LoadRemotePlugins()

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/shada.vim
Sourced 1 time
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_shada_plugin')
                              finish
    1              0.000001 endif
    1              0.000010 let g:loaded_shada_plugin = 1
                            
    1              0.000002 augroup ShaDaCommands
    1              0.000042   autocmd!
    1              0.000016   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b')))
                                    \ |setlocal filetype=shada
    1              0.000007   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
    1              0.000008   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |if writefile(shada#get_binstrings(getline(1, '$')),
                                                   \expand('<afile>'), 'b') == 0
                                    \ |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))
                                                           \? 0
                                                           \: stridx(&cpoptions, '+') != -1)
                                    \ |endif
    1              0.000010   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'b')
    1              0.000007   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z]
                                    \ :if !empty(v:cmdarg)|throw '++opt not supported'|endif
                                    \ |call writefile(
                                          \shada#get_binstrings(getline(min([line("'["), line("']")]),
                                                                       \max([line("'["), line("']")]))),
                                          \expand('<afile>'),
                                          \'ab')
    1              0.000005   autocmd SourceCmd *.shada,*.shada.tmp.[a-z]
                                    \ :execute 'rshada' fnameescape(expand('<afile>'))
    1              0.000003 augroup END

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/spellfile.vim
Sourced 1 time
Total time:   0.000085
 Self time:   0.000085

count  total (s)   self (s)
                            " Vim plugin for downloading spell files
                            
    1              0.000011 if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
                              finish
    1              0.000001 endif
    1              0.000006 let loaded_spellfile_plugin = 1
                            
    1              0.000006 autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/tarPlugin.vim
Sourced 1 time
Total time:   0.000331
 Self time:   0.000331

count  total (s)   self (s)
                            " tarPlugin.vim -- a Vim plugin for browsing tarfiles
                            " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
                            " Modified by Charles E. Campbell
                            " Distributed under the GNU General Public License.
                            "
                            " Updates are available from <http://michael.toren.net/code/>.  If you
                            " find this script useful, or have suggestions for improvements, please
                            " let me know.
                            " Also look there for further comments and documentation.
                            "
                            " This part only sets the autocommands.  The functions are in autoload/tar.vim.
                            " ---------------------------------------------------------------------
                            "  Load Once: {{{1
    1              0.000007 if &cp || exists("g:loaded_tarPlugin")
                             finish
    1              0.000001 endif
    1              0.000006 let g:loaded_tarPlugin = "v32"
    1              0.000003 let s:keepcpo          = &cpo
    1              0.000006 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            "  Public Interface: {{{1
    1              0.000002 augroup tar
    1              0.000042   au!
    1              0.000005   au BufReadCmd   tarfile::*	call tar#Read(expand("<amatch>"), 1)
    1              0.000004   au FileReadCmd  tarfile::*	call tar#Read(expand("<amatch>"), 0)
    1              0.000003   au BufWriteCmd  tarfile::*	call tar#Write(expand("<amatch>"))
    1              0.000003   au FileWriteCmd tarfile::*	call tar#Write(expand("<amatch>"))
                            
    1              0.000002   if has("unix")
    1              0.000004    au BufReadCmd   tarfile::*/*	call tar#Read(expand("<amatch>"), 1)
    1              0.000003    au FileReadCmd  tarfile::*/*	call tar#Read(expand("<amatch>"), 0)
    1              0.000003    au BufWriteCmd  tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000003    au FileWriteCmd tarfile::*/*	call tar#Write(expand("<amatch>"))
    1              0.000001   endif
                            
    1              0.000003   au BufReadCmd   *.tar.gz		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.lrp			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.bz2		call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.Z		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tbz			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tgz			call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.lzma	call tar#Browse(expand("<amatch>"))
    1              0.000003   au BufReadCmd   *.tar.xz		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.txz			call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tar.zst		call tar#Browse(expand("<amatch>"))
    1              0.000002   au BufReadCmd   *.tzs			call tar#Browse(expand("<amatch>"))
    1              0.000001 augroup END
    1              0.000006 com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
                            
                            " ---------------------------------------------------------------------
                            " Restoration And Modelines: {{{1
                            " vim: fdm=marker
    1              0.000005 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/tohtml.vim
Sourced 1 time
Total time:   0.000326
 Self time:   0.000326

count  total (s)   self (s)
                            " Vim plugin for converting a syntax highlighted file to HTML.
                            " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
                            " Last Change: 2019 Nov 13
                            "
                            " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
                            " $VIMRUNTIME/syntax/2html.vim
                            "
    1              0.000004 if exists('g:loaded_2html_plugin')
                              finish
    1              0.000001 endif
    1              0.000006 let g:loaded_2html_plugin = 'vim8.1_v2'
                            
                            "
                            " Changelog: {{{
                            "   8.1_v2  (this version): - Fix Bitbucket issue #19: fix calculation of tab
                            "                             stop position to use in expanding a tab, when that
                            "                             tab occurs after a syntax match which in turn
                            "                             comes after previously expanded tabs.
                            "                           - Set eventignore while splitting a window for the
                            "                             destination file to ignore FileType events;
                            "                             speeds up processing when the destination file
                            "                             already exists and HTML highlight takes too long.
                            "                           - Fix Bitbucket issue #20: progress bar could not be
                            "                             seen when DiffDelete background color matched
                            "                             StatusLine background color. Added TOhtmlProgress
                            "                             highlight group for manual user override, but
                            "                             calculate it to be visible compared to StatusLine
                            "                             by default.
                            "                           - Fix Bitbucket issue #1: Remove workaround for old
                            "                             browsers which don't support 'ch' CSS unit, since
                            "                             all modern browsers, including IE>=9, support it.
                            "                           - Fix Bitbucket issue #10: support termguicolors
                            "                           - Fix Bitbucket issue #21: default to using
                            "                             generated content instead of <input> tags for
                            "                             uncopyable text, so that text is correctly
                            "                             prevented from being copied in chrome. Use
                            "                             g:html_use_input_for_pc option to control the
                            "                             method used.
                            "                           - Switch to HTML5 to allow using vnu as a validator
                            "                             in unit test.
                            "                           - Fix fallback sizing of <input> tags for browsers
                            "                             without "ch" support.
                            "                           - Fix cursor on unselectable diff filler text.
                            "   8.1_v1  (Vim 8.1.0528): - Fix Bitbucket issue #6: Don't generate empty
                            "                             script tag.
                            "                           - Fix Bitbucket issue #5: javascript should
                            "                             declare variables with "var".
                            "                           - Fix Bitbucket issue #13: errors thrown sourcing
                            "                             2html.vim directly when plugins not loaded.
                            "                           - Fix Bitbucket issue #16: support 'vartabstop'.
                            "
                            "   7.4 updates: {{{
                            "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
                            "                           an empty buffer. Jan Stocker: allow g:html_font to
                            "                           take a list so it is easier to specfiy fallback
                            "                           fonts in the generated CSS.
                            "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
                            "			    also for version-specific modelines like "vim>703:".
                            "}}}
                            "
                            "   7.3 updates: {{{
                            "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
                            "			    g:html_line_ids=0. Allow customizing
                            "			    important IDs (like line IDs and fold IDs) using
                            "			    g:html_id_expr evaluated when the buffer conversion
                            "			    is started.
                            "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
                            "			    insert modeline to set it to manual.
                            "			    Fix bug: diff mode with 2 unsaved buffers creates a
                            "			    duplicate of one buffer instead of including both.
                            "			    Add anchors to each line so you can put '#L123'
                            "			    or '#123' at the end of the URL to jump to line 123
                            "			    (idea by Andy Spencer). Add javascript to open folds
                            "			    to show the anchor being jumped to if it is hidden.
                            "			    Fix XML validation error: &nsbp; not part of XML.
                            "			    Allow TOhtml to chain together with other commands
                            "			    using |.
                            "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
                            "			    highlight groups make up the start-of-modeline text.
                            "			    Improve render time of page with uncopyable regions
                            "			    by not using one-input-per-char. Change name of
                            "			    uncopyable option from html_unselectable to
                            "			    html_prevent_copy. Added html_no_invalid option and
                            "			    default to inserting invalid markup for uncopyable
                            "			    regions to prevent MS Word from pasting undeletable
                            "			    <input> elements. Fix 'cpo' handling (Thilo Six).
                            "		 7.3_v12b1: Add html_unselectable option. Rework logic to
                            "			    eliminate post-processing substitute commands in
                            "			    favor of doing the work up front. Remove unnecessary
                            "			    special treatment of 'LineNr' highlight group. Minor
                            "			    speed improvements. Fix modeline mangling in
                            "			    generated output so it works for text in the first
                            "			    column. Fix missing line number and fold column in
                            "			    diff filler lines. Fix that some fonts have a 1px
                            "			    gap (using a dirty hack, improvements welcome). Add
                            "			    "colorscheme" meta tag. Does NOT include support for
                            "			    the new default foldtext added in v11, as the patch
                            "			    adding it has not yet been included in Vim.
                            "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
                            "			    Brabandt in
                            "			    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
                            "			    This patch has not yet been included in Vim, thus
                            "			    these changes are removed in the next version.
                            "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
                            "			    multiple nested folds with dynamic folding on.
                            "			    Also fix problem with foldtext in this situation.
                            "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
                            "			    and without html_no_pre, default value same as
                            "			    'wrap' option, (Andy Spencer). Don't use
                            "			    'fileencoding' for converted document encoding if
                            "			    'buftype' indicates a special buffer which isn't
                            "			    written.
                            "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
                            "			    characters in generated output (Andy Spencer).
                            "			    Escape text that looks like a modeline so Vim
                            "			    doesn't use anything in the converted HTML as a
                            "			    modeline. Bugfixes: Fix folding when a fold starts
                            "			    before the conversion range. Remove fold column when
                            "			    there are no folds.
                            "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
                            "		  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
                            "		  7.3_v7b2: Remove automatic detection of encodings that are not
                            "			    supported by all major browsers according to
                            "			    http://wiki.whatwg.org/wiki/Web_Encodings and
                            "			    convert to UTF-8 for all Unicode encodings. Make
                            "			    HTML encoding to Vim encoding detection be
                            "			    case-insensitive for built-in pairs.
                            "		  7.3_v7b1: Remove use of setwinvar() function which cannot be
                            "			    called in restricted mode (Andy Spencer). Use
                            "			    'fencoding' instead of 'encoding' to determine by
                            "			    charset, and make sure the 'fenc' of the generated
                            "			    file matches its indicated charset. Add charsets for
                            "			    all of Vim's natively supported encodings.
                            "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
                            "			    user settings interfering with diff mode generation,
                            "			    trailing whitespace (e.g. line number column) when
                            "			    using html_no_pre, and bugs when using
                            "			    html_hover_unfold.
                            "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
                            "			    folds in diff mode when first line was folded.
                            "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
                            "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
                            "			    default to true when not set to anything. Use strict
                            "			    doctypes where possible. Rename use_xhtml option to
                            "			    html_use_xhtml for consistency. Use .xhtml extension
                            "			    when using this option. Add meta tag for settings.
                            "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
                            "			    diff colors and the normal syntax colors
                            "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
                            "}}}
                            "}}}
                            
                            " TODO: {{{
                            "   * Check the issue tracker:
                            "     https://bitbucket.org/fritzophrenic/vim-tohtml/issues?status=new&status=open
                            "   * Options for generating the CSS in external style sheets. New :TOcss
                            "     command to convert the current color scheme into a (mostly) generic CSS
                            "     stylesheet which can be re-used. Alternate stylesheet support? Good start
                            "     by Erik Falor
                            "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
                            "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
                            "     term) to use for the styling. Suggestion by "nacitar".
                            "   * Add way to override or specify which RGB colors map to the color numbers
                            "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
                            "   * Disable filetype detection until after all processing is done.
                            "   * Add option for not generating the hyperlink on stuff that looks like a
                            "     URL? Or just color the link to fit with the colorscheme (and only special
                            "     when hovering)?
                            "   * Bug: Opera does not allow printing more than one page if uncopyable
                            "     regions is turned on. Possible solution: Add normal text line numbers with
                            "     display:none, set to display:inline for print style sheets, and hide
                            "     <input> elements for print, to allow Opera printing multiple pages (and
                            "     other uncopyable areas?). May need to make the new text invisible to IE
                            "     with conditional comments to prevent copying it, IE for some reason likes
                            "     to copy hidden text. Other browsers too?
                            "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
                            "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
                            "     on Windows). Perhaps it is font related?
                            "   * Bug: still some gaps in the fold column when html_prevent_copy contains
                            "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
                            "     on diff lines though.
                            "   * Undercurl support via CSS3, with fallback to dotted or something:
                            "	https://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
                            "   * Redo updates for modified default foldtext (v11) when/if the patch is
                            "     accepted to modify it.
                            "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
                            "		+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
                            "		+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
                            "     does not show the whole diff filler as it is supposed to?
                            "   * Bug: when 'isprint' is wrong for the current encoding, will generate
                            "     invalid content. Can/should anything be done about this? Maybe a separate
                            "     plugin to correct 'isprint' based on encoding?
                            "   * Check to see if the windows-125\d encodings actually work in Unix without
                            "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
                            "   * Font auto-detection similar to
                            "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
                            "     platforms.
                            "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
                            "	- listchars support
                            "	- full-line background highlight
                            "	- other?
                            "   * Make it so deleted lines in a diff don't create side-scrolling (get it
                            "     free with full-line background highlight above).
                            "   * Restore open/closed folds and cursor position after processing each file
                            "     with option not to restore for speed increase.
                            "   * Add extra meta info (generation time, etc.)?
                            "   * Tidy up so we can use strict doctype in even more situations
                            "   * Implementation detail: add threshold for writing the lines to the html
                            "     buffer before we're done (5000 or so lines should do it)
                            "   * TODO comments for code cleanup scattered throughout
                            "}}}
                            
                            " Define the :TOhtml command when:
                            " - 'compatible' is not set
                            " - this plugin or user override was not already loaded
                            " - user commands are available. {{{
    1              0.000011 if !&cp && !exists(":TOhtml") && has("user_commands")
    1              0.000007   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
    1              0.000001 endif "}}}
                            
                            " Make sure any patches will probably use consistent indent
                            "   vim: ts=8 sw=2 sts=2 noet fdm=marker

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/tutor.vim
Sourced 1 time
Total time:   0.000209
 Self time:   0.000209

count  total (s)   self (s)
    1              0.000008 if exists('g:loaded_tutor_mode_plugin') || &compatible
                                finish
    1              0.000001 endif
    1              0.000007 let g:loaded_tutor_mode_plugin = 1
                            
    1              0.000008 command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)

SCRIPT  /usr/local/Cellar/neovim/0.6.1/share/nvim/runtime/plugin/zipPlugin.vim
Sourced 1 time
Total time:   0.000389
 Self time:   0.000389

count  total (s)   self (s)
                            " zipPlugin.vim: Handles browsing zipfiles
                            "            PLUGIN PORTION
                            " Date:			Jan 07, 2020
                            " Maintainer:	Charles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
                            " License:		Vim License  (see vim's :help license)
                            " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
                            "               Permission is hereby granted to use and distribute this code,
                            "               with or without modifications, provided that this copyright
                            "               notice is copied with it. Like anything else that's free,
                            "               zipPlugin.vim is provided *as is* and comes with no warranty
                            "               of any kind, either expressed or implied. By using this
                            "               plugin, you agree that in no event will the copyright
                            "               holder be liable for any damages resulting from the use
                            "               of this software.
                            "
                            " (James 4:8 WEB) Draw near to God, and he will draw near to you.
                            " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
                            " ---------------------------------------------------------------------
                            " Load Once: {{{1
    1              0.000008 if &cp || exists("g:loaded_zipPlugin")
                             finish
    1              0.000001 endif
    1              0.000023 let g:loaded_zipPlugin = "v32"
    1              0.000003 let s:keepcpo          = &cpo
    1              0.000005 set cpo&vim
                            
                            " ---------------------------------------------------------------------
                            " Options: {{{1
    1              0.000003 if !exists("g:zipPlugin_ext")
    1              0.000009  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
    1              0.000001 endif
                            
                            " ---------------------------------------------------------------------
                            " Public Interface: {{{1
    1              0.000002 augroup zip
    1              0.000045  au!
    1              0.000006  au BufReadCmd   zipfile:*	call zip#Read(expand("<amatch>"), 1)
    1              0.000010  au FileReadCmd  zipfile:*	call zip#Read(expand("<amatch>"), 0)
    1              0.000003  au BufWriteCmd  zipfile:*	call zip#Write(expand("<amatch>"))
    1              0.000003  au FileWriteCmd zipfile:*	call zip#Write(expand("<amatch>"))
                            
    1              0.000002  if has("unix")
    1              0.000003   au BufReadCmd   zipfile:*/*	call zip#Read(expand("<amatch>"), 1)
    1              0.000003   au FileReadCmd  zipfile:*/*	call zip#Read(expand("<amatch>"), 0)
    1              0.000003   au BufWriteCmd  zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000003   au FileWriteCmd zipfile:*/*	call zip#Write(expand("<amatch>"))
    1              0.000001  endif
                            
    1              0.000060  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
    1              0.000001 augroup END
                            
                            " ---------------------------------------------------------------------
                            "  Restoration And Modelines: {{{1
                            "  vim: fdm=marker
    1              0.000005 let &cpo= s:keepcpo
    1              0.000004 unlet s:keepcpo

SCRIPT  /Users/mochi/.local/share/nvim/plugged/dracula/after/plugin/dracula.vim
Sourced 1 time
Total time:   0.001652
 Self time:   0.001515

count  total (s)   self (s)
    1   0.000156   0.000020 if dracula#should_abort()
                              finish
    1              0.000001 endif
                            
                            " Fzf: {{{
    1              0.000006 if exists('g:loaded_fzf') && ! exists('g:fzf_colors')
    1              0.000041   let g:fzf_colors = {
                                \ 'fg':      ['fg', 'Normal'],
                                \ 'bg':      ['bg', 'Normal'],
                                \ 'hl':      ['fg', 'Search'],
                                \ 'fg+':     ['fg', 'Normal'],
                                \ 'bg+':     ['bg', 'Normal'],
                                \ 'hl+':     ['fg', 'DraculaOrange'],
                                \ 'info':    ['fg', 'DraculaPurple'],
                                \ 'border':  ['fg', 'Ignore'],
                                \ 'prompt':  ['fg', 'DraculaGreen'],
                                \ 'pointer': ['fg', 'Exception'],
                                \ 'marker':  ['fg', 'Keyword'],
                                \ 'spinner': ['fg', 'Label'],
                                \ 'header':  ['fg', 'Comment'],
                                \}
    1              0.000001 endif
                            "}}}
                            " ALE: {{{
    1              0.000002 if exists('g:ale_enabled')
                              hi! link ALEError              DraculaErrorLine
                              hi! link ALEWarning            DraculaWarnLine
                              hi! link ALEInfo               DraculaInfoLine
                            
                              hi! link ALEErrorSign          DraculaRed
                              hi! link ALEWarningSign        DraculaOrange
                              hi! link ALEInfoSign           DraculaCyan
                            
                              hi! link ALEVirtualTextError   Comment
                              hi! link ALEVirtualTextWarning Comment
    1              0.000001 endif
                            " }}}
                            " CtrlP: {{{
    1              0.000002 if exists('g:loaded_ctrlp')
                              hi! link CtrlPMatch     IncSearch
                              hi! link CtrlPBufferHid Normal
    1              0.000000 endif
                            " }}}
                            " GitGutter / gitsigns: {{{
    1              0.000002 if exists('g:loaded_gitgutter')
    1              0.000005   hi! link GitGutterAdd    DiffAdd
    1              0.000002   hi! link GitGutterChange DiffChange
    1              0.000001   hi! link GitGutterDelete DiffDelete
    1              0.000001 endif
    1              0.000512 if has('nvim-0.5') && luaeval("pcall(require, 'gitsigns')")
                              " https://github.com/lewis6991/gitsigns.nvim requires nvim > 0.5
                              " has('nvim-0.5') checks >= 0.5, so this should be future-proof.
                              hi! link GitSignsAdd      DiffAdd
                              hi! link GitSignsAddLn    DiffAdd
                              hi! link GitSignsAddNr    DiffAdd
                              hi! link GitSignsChange   DiffChange
                              hi! link GitSignsChangeLn DiffChange
                              hi! link GitSignsChangeNr DiffChange
                              hi! link GitSignsDelete   DiffDelete
                              hi! link GitSignsDeleteLn DiffDelete
                              hi! link GitSignsDeleteNr DiffDelete
    1              0.000001 endif
                            " }}}
                            " Tree-sitter: {{{
                            " The nvim-treesitter library defines many global highlight groups that are
                            " linked to the regular vim syntax highlight groups. We only need to redefine
                            " those highlight groups when the defaults do not match the dracula
                            " specification.
                            " https://github.com/nvim-treesitter/nvim-treesitter/blob/master/plugin/nvim-treesitter.vim
    1              0.000006 if exists('g:loaded_nvim_treesitter')
                              " # Misc
                              hi! link TSPunctSpecial Special
                              " # Constants
                              hi! link TSConstMacro Macro
                              hi! link TSStringEscape Character
                              hi! link TSSymbol DraculaPurple
                              hi! link TSAnnotation DraculaYellow
                              hi! link TSAttribute DraculaGreenItalic
                              " # Functions
                              hi! link TSFuncBuiltin DraculaCyan
                              hi! link TSFuncMacro Function
                              hi! link TSParameter DraculaOrangeItalic
                              hi! link TSParameterReference DraculaOrange
                              hi! link TSField DraculaOrange
                              hi! link TSConstructor DraculaCyan
                              " # Keywords
                              hi! link TSLabel DraculaPurpleItalic
                              " # Variable
                              hi! link TSVariableBuiltin DraculaPurpleItalic
                              " # Text
                              hi! link TSStrong DraculaFgBold
                              hi! link TSEmphasis DraculaFg
                              hi! link TSUnderline Underlined
                              hi! link TSTitle DraculaYellow
                              hi! link TSLiteral DraculaYellow
                              hi! link TSURI DraculaYellow
                              " HTML and JSX tag attributes. By default, this group is linked to TSProperty,
                              " which in turn links to Identifer (white).
                              hi! link TSTagAttribute DraculaGreenItalic
    1              0.000001 endif
                            " }}}
                            " nvim-cmp: {{{
                            " A completion engine plugin for neovim written in Lua.
                            " https://github.com/hrsh7th/nvim-cmp
    1              0.000002 if exists('g:loaded_cmp')
                              hi! link CmpItemAbbrDeprecated DraculaError
                            
                              hi! link CmpItemAbbrMatch DraculaCyan
                              hi! link CmpItemAbbrMatchFuzzy DraculaCyan
                            
                              hi! link CmpItemKindText DraculaFg
                              hi! link CmpItemKindMethod Function
                              hi! link CmpItemKindFunction Function
                              hi! link CmpItemKindConstructor DraculaCyan
                              hi! link CmpItemKindField DraculaOrange
                              hi! link CmpItemKindVariable DraculaPurpleItalic
                              hi! link CmpItemKindClass DraculaCyan
                              hi! link CmpItemKindInterface DraculaCyan
                              hi! link CmpItemKindModule DraculaYellow
                              hi! link CmpItemKindProperty DraculaPink
                              hi! link CmpItemKindUnit DraculaFg
                              hi! link CmpItemKindValue DraculaYellow
                              hi! link CmpItemKindEnum DraculaPink
                              hi! link CmpItemKindKeyword DraculaPink
                              hi! link CmpItemKindSnippet DraculaFg
                              hi! link CmpItemKindColor DraculaYellow
                              hi! link CmpItemKindFile DraculaYellow
                              hi! link CmpItemKindReference DraculaOrange
                              hi! link CmpItemKindFolder DraculaYellow
                              hi! link CmpItemKindEnumMember DraculaPurple
                              hi! link CmpItemKindConstant DraculaPurple
                              hi! link CmpItemKindStruct DraculaPink
                              hi! link CmpItemKindEvent DraculaFg
                              hi! link CmpItemKindOperator DraculaPink
                              hi! link CmpItemKindTypeParameter DraculaCyan
                            
                              hi! link CmpItemMenu Comment
    1              0.000001 endif
                            " }}}
                            
                            " vim: fdm=marker ts=2 sts=2 sw=2 fdl=0:

